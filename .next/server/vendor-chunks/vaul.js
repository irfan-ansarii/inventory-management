"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/vaul";
exports.ids = ["vendor-chunks/vaul"];
exports.modules = {

/***/ "(ssr)/./node_modules/vaul/dist/index.mjs":
/*!******************************************!*\
  !*** ./node_modules/vaul/dist/index.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Drawer: () => (/* binding */ Drawer)\n/* harmony export */ });\n/* harmony import */ var _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @radix-ui/react-dialog */ \"(ssr)/./node_modules/@radix-ui/react-dialog/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ Drawer auto */ function __insertCSS(code) {\n    if (!code || typeof document == \"undefined\") return;\n    let head = document.head || document.getElementsByTagName(\"head\")[0];\n    let style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    head.appendChild(style);\n    style.styleSheet ? style.styleSheet.cssText = code : style.appendChild(document.createTextNode(code));\n}\n\n\n\nconst DrawerContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    drawerRef: {\n        current: null\n    },\n    overlayRef: {\n        current: null\n    },\n    scaleBackground: ()=>{},\n    onPress: ()=>{},\n    onRelease: ()=>{},\n    onDrag: ()=>{},\n    onNestedDrag: ()=>{},\n    onNestedOpenChange: ()=>{},\n    onNestedRelease: ()=>{},\n    openProp: undefined,\n    dismissible: false,\n    handleOnly: false,\n    isOpen: false,\n    isDragging: false,\n    keyboardIsOpen: {\n        current: false\n    },\n    snapPointsOffset: null,\n    snapPoints: null,\n    modal: false,\n    shouldFade: false,\n    activeSnapPoint: null,\n    onOpenChange: ()=>{},\n    setActiveSnapPoint: ()=>{},\n    visible: false,\n    closeDrawer: ()=>{},\n    setVisible: ()=>{},\n    direction: \"bottom\"\n});\nconst useDrawerContext = ()=>{\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DrawerContext);\n    if (!context) {\n        throw new Error(\"useDrawerContext must be used within a Drawer.Root\");\n    }\n    return context;\n};\n__insertCSS(\"[vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32, .72, 0, 1)}[vaul-drawer][vaul-drawer-direction=bottom]{transform:translate3d(0,100%,0)}[vaul-drawer][vaul-drawer-direction=top]{transform:translate3d(0,-100%,0)}[vaul-drawer][vaul-drawer-direction=left]{transform:translate3d(-100%,0,0)}[vaul-drawer][vaul-drawer-direction=right]{transform:translate3d(100%,0,0)}.vaul-dragging .vaul-scrollable [vault-drawer-direction=top]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=bottom]{overflow-y:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=left]{overflow-x:hidden!important}.vaul-dragging .vaul-scrollable [vault-drawer-direction=right]{overflow-x:hidden!important}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=top]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height,0),0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=left]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-drawer][vaul-drawer-visible=true][vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height,0),0,0)}[vaul-overlay]{opacity:0;transition:opacity .5s cubic-bezier(.32, .72, 0, 1)}[vaul-overlay][vaul-drawer-visible=true]{opacity:1}[vaul-drawer]::after{content:'';position:absolute;background:inherit;background-color:inherit}[vaul-drawer][vaul-drawer-direction=top]::after{top:initial;bottom:100%;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=bottom]::after{top:100%;bottom:initial;left:0;right:0;height:200%}[vaul-drawer][vaul-drawer-direction=left]::after{left:initial;right:100%;top:0;bottom:0;width:200%}[vaul-drawer][vaul-drawer-direction=right]::after{left:100%;right:initial;top:0;bottom:0;width:200%}[vaul-handle]{display:block;position:relative;opacity:.8;margin-left:auto;margin-right:auto;height:5px;width:56px;border-radius:1rem;touch-action:pan-y;cursor:grab}[vaul-handle]:active,[vaul-handle]:hover{opacity:1}[vaul-handle]:active{cursor:grabbing}[vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}[vaul-overlay][vaul-snap-points=true]:not([vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[vaul-overlay][vaul-snap-points-overlay=true]:not([vaul-drawer-visible=false]){opacity:1}@media (hover:hover) and (pointer:fine){[vaul-drawer]{user-select:none}}@media (pointer:fine){[vaul-handle-hitarea]:{width:100%;height:100%}}\");\n// This code comes from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/overlays/src/usePreventScroll.ts\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction chain(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks){\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\nfunction isMac() {\n    return testPlatform(/^Mac/);\n}\nfunction isIPhone() {\n    return testPlatform(/^iPhone/);\n}\nfunction isIPad() {\n    return testPlatform(/^iPad/) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    isMac() && navigator.maxTouchPoints > 1;\n}\nfunction isIOS() {\n    return isIPhone() || isIPad();\n}\nfunction testPlatform(re) {\n    return  false ? 0 : undefined;\n}\n// @ts-ignore\nconst visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction isScrollable(node) {\n    let style = window.getComputedStyle(node);\n    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\nfunction getScrollParent(node) {\n    if (isScrollable(node)) {\n        node = node.parentElement;\n    }\n    while(node && !isScrollable(node)){\n        node = node.parentElement;\n    }\n    return node || document.scrollingElement || document.documentElement;\n}\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */ function usePreventScroll(options = {}) {\n    let { isDisabled } = options;\n    useIsomorphicLayoutEffect(()=>{\n        if (isDisabled) {\n            return;\n        }\n        preventScrollCount++;\n        if (preventScrollCount === 1) {\n            if (isIOS()) {\n                restore = preventScrollMobileSafari();\n            } else {\n                restore = preventScrollStandard();\n            }\n        }\n        return ()=>{\n            preventScrollCount--;\n            if (preventScrollCount === 0) {\n                restore();\n            }\n        };\n    }, [\n        isDisabled\n    ]);\n}\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n    return chain(setStyle(document.documentElement, \"paddingRight\", `${window.innerWidth - document.documentElement.clientWidth}px`));\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n    let scrollable;\n    let lastY = 0;\n    let onTouchStart = (e)=>{\n        // Store the nearest scrollable parent element from the element that the user touched.\n        scrollable = getScrollParent(e.target);\n        if (scrollable === document.documentElement && scrollable === document.body) {\n            return;\n        }\n        lastY = e.changedTouches[0].pageY;\n    };\n    let onTouchMove = (e)=>{\n        // Prevent scrolling the window.\n        if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n            e.preventDefault();\n            return;\n        }\n        // Prevent scrolling up when at the top and scrolling down when at the bottom\n        // of a nested scrollable area, otherwise mobile Safari will start scrolling\n        // the window instead. Unfortunately, this disables bounce scrolling when at\n        // the top but it's the best we can do.\n        let y = e.changedTouches[0].pageY;\n        let scrollTop = scrollable.scrollTop;\n        let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n        if (bottom === 0) {\n            return;\n        }\n        if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {\n            e.preventDefault();\n        }\n        lastY = y;\n    };\n    let onTouchEnd = (e)=>{\n        let target = e.target;\n        // Apply this change if we're not already focused on the target element\n        if (isInput(target) && target !== document.activeElement) {\n            e.preventDefault();\n            // Apply a transform to trick Safari into thinking the input is at the top of the page\n            // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n            // be done before the \"focus\" event, so we have to focus the element ourselves.\n            target.style.transform = \"translateY(-2000px)\";\n            target.focus();\n            requestAnimationFrame(()=>{\n                target.style.transform = \"\";\n            });\n        }\n    };\n    let onFocus = (e)=>{\n        let target = e.target;\n        if (isInput(target)) {\n            // Transform also needs to be applied in the focus event in cases where focus moves\n            // other than tapping on an input directly, e.g. the next/previous buttons in the\n            // software keyboard. In these cases, it seems applying the transform in the focus event\n            // is good enough, whereas when tapping an input, it must be done before the focus event. ðŸ¤·â€â™‚ï¸\n            target.style.transform = \"translateY(-2000px)\";\n            requestAnimationFrame(()=>{\n                target.style.transform = \"\";\n                // This will have prevented the browser from scrolling the focused element into view,\n                // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n                if (visualViewport) {\n                    if (visualViewport.height < window.innerHeight) {\n                        // If the keyboard is already visible, do this after one additional frame\n                        // to wait for the transform to be removed.\n                        requestAnimationFrame(()=>{\n                            scrollIntoView(target);\n                        });\n                    } else {\n                        // Otherwise, wait for the visual viewport to resize before scrolling so we can\n                        // measure the correct position to scroll to.\n                        visualViewport.addEventListener(\"resize\", ()=>scrollIntoView(target), {\n                            once: true\n                        });\n                    }\n                }\n            });\n        }\n    };\n    let onWindowScroll = ()=>{\n        // Last resort. If the window scrolled, scroll it back to the top.\n        // It should always be at the top because the body will have a negative margin (see below).\n        window.scrollTo(0, 0);\n    };\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n    let restoreStyles = chain(setStyle(document.documentElement, \"paddingRight\", `${window.innerWidth - document.documentElement.clientWidth}px`));\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n    let removeEvents = chain(addEvent(document, \"touchstart\", onTouchStart, {\n        passive: false,\n        capture: true\n    }), addEvent(document, \"touchmove\", onTouchMove, {\n        passive: false,\n        capture: true\n    }), addEvent(document, \"touchend\", onTouchEnd, {\n        passive: false,\n        capture: true\n    }), addEvent(document, \"focus\", onFocus, true), addEvent(window, \"scroll\", onWindowScroll));\n    return ()=>{\n        // Restore styles and scroll the page back to where it was.\n        restoreStyles();\n        removeEvents();\n        window.scrollTo(scrollX, scrollY);\n    };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element, style, value) {\n    let cur = element.style[style];\n    element.style[style] = value;\n    return ()=>{\n        element.style[style] = cur;\n    };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent(target, event, handler, options) {\n    // @ts-ignore\n    target.addEventListener(event, handler, options);\n    return ()=>{\n        // @ts-ignore\n        target.removeEventListener(event, handler, options);\n    };\n}\nfunction scrollIntoView(target) {\n    let root = document.scrollingElement || document.documentElement;\n    while(target && target !== root){\n        // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n        let scrollable = getScrollParent(target);\n        if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n            let scrollableTop = scrollable.getBoundingClientRect().top;\n            let targetTop = target.getBoundingClientRect().top;\n            let targetBottom = target.getBoundingClientRect().bottom;\n            const keyboardHeight = scrollable.getBoundingClientRect().bottom;\n            if (targetBottom > keyboardHeight) {\n                scrollable.scrollTop += targetTop - scrollableTop;\n            }\n        }\n        // @ts-ignore\n        target = scrollable.parentElement;\n    }\n}\nfunction isInput(target) {\n    return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\n// This code comes from https://github.com/radix-ui/primitives/tree/main/packages/react/compose-refs\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */ function setRef(ref, value) {\n    if (typeof ref === \"function\") {\n        ref(value);\n    } else if (ref !== null && ref !== undefined) {\n        ref.current = value;\n    }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */ function composeRefs(...refs) {\n    return (node)=>refs.forEach((ref)=>setRef(ref, node));\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */ function useComposedRefs(...refs) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(composeRefs(...refs), refs);\n}\nlet previousBodyPosition = null;\nfunction usePositionFixed({ isOpen, modal, nested, hasBeenOpened, preventScrollRestoration, noBodyStyles }) {\n    const [activeUrl, setActiveUrl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=> false ? 0 : \"\");\n    const scrollPos = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const setPositionFixed = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        // If previousBodyPosition is already set, don't set it again.\n        if (previousBodyPosition === null && isOpen && !noBodyStyles) {\n            previousBodyPosition = {\n                position: document.body.style.position,\n                top: document.body.style.top,\n                left: document.body.style.left,\n                height: document.body.style.height,\n                right: \"unset\"\n            };\n            // Update the dom inside an animation frame\n            const { scrollX, innerHeight } = window;\n            document.body.style.setProperty(\"position\", \"fixed\", \"important\");\n            Object.assign(document.body.style, {\n                top: `${-scrollPos.current}px`,\n                left: `${-scrollX}px`,\n                right: \"0px\",\n                height: \"auto\"\n            });\n            window.setTimeout(()=>window.requestAnimationFrame(()=>{\n                    // Attempt to check if the bottom bar appeared due to the position change\n                    const bottomBarHeight = innerHeight - window.innerHeight;\n                    if (bottomBarHeight && scrollPos.current >= innerHeight) {\n                        // Move the content further up so that the bottom bar doesn't hide it\n                        document.body.style.top = `${-(scrollPos.current + bottomBarHeight)}px`;\n                    }\n                }), 300);\n        }\n    }, [\n        isOpen\n    ]);\n    const restorePositionSetting = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (previousBodyPosition !== null && !noBodyStyles) {\n            // Convert the position from \"px\" to Int\n            const y = -parseInt(document.body.style.top, 10);\n            const x = -parseInt(document.body.style.left, 10);\n            // Restore styles\n            Object.assign(document.body.style, previousBodyPosition);\n            window.requestAnimationFrame(()=>{\n                if (preventScrollRestoration && activeUrl !== window.location.href) {\n                    setActiveUrl(window.location.href);\n                    return;\n                }\n                window.scrollTo(x, y);\n            });\n            previousBodyPosition = null;\n        }\n    }, [\n        activeUrl\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        function onScroll() {\n            scrollPos.current = window.scrollY;\n        }\n        onScroll();\n        window.addEventListener(\"scroll\", onScroll);\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll);\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (nested || !hasBeenOpened) return;\n        // This is needed to force Safari toolbar to show **before** the drawer starts animating to prevent a gnarly shift from happening\n        if (isOpen) {\n            // avoid for standalone mode (PWA)\n            const isStandalone = window.matchMedia(\"(display-mode: standalone)\").matches;\n            !isStandalone && setPositionFixed();\n            if (!modal) {\n                window.setTimeout(()=>{\n                    restorePositionSetting();\n                }, 500);\n            }\n        } else {\n            restorePositionSetting();\n        }\n    }, [\n        isOpen,\n        hasBeenOpened,\n        activeUrl,\n        modal,\n        nested,\n        setPositionFixed,\n        restorePositionSetting\n    ]);\n    return {\n        restorePositionSetting\n    };\n}\nconst cache = new WeakMap();\nfunction set(el, styles, ignoreCache = false) {\n    if (!el || !(el instanceof HTMLElement)) return;\n    let originalStyles = {};\n    Object.entries(styles).forEach(([key, value])=>{\n        if (key.startsWith(\"--\")) {\n            el.style.setProperty(key, value);\n            return;\n        }\n        originalStyles[key] = el.style[key];\n        el.style[key] = value;\n    });\n    if (ignoreCache) return;\n    cache.set(el, originalStyles);\n}\nfunction reset(el, prop) {\n    if (!el || !(el instanceof HTMLElement)) return;\n    let originalStyles = cache.get(el);\n    if (!originalStyles) {\n        return;\n    }\n    if (prop) {\n        el.style[prop] = originalStyles[prop];\n    } else {\n        Object.entries(originalStyles).forEach(([key, value])=>{\n            el.style[key] = value;\n        });\n    }\n}\nconst isVertical = (direction)=>{\n    switch(direction){\n        case \"top\":\n        case \"bottom\":\n            return true;\n        case \"left\":\n        case \"right\":\n            return false;\n        default:\n            return direction;\n    }\n};\nfunction getTranslate(element, direction) {\n    if (!element) {\n        return null;\n    }\n    const style = window.getComputedStyle(element);\n    const transform = style.transform || style.webkitTransform || style.mozTransform;\n    let mat = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (mat) {\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n        return parseFloat(mat[1].split(\", \")[isVertical(direction) ? 13 : 12]);\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n    mat = transform.match(/^matrix\\((.+)\\)$/);\n    return mat ? parseFloat(mat[1].split(\", \")[isVertical(direction) ? 5 : 4]) : null;\n}\nfunction dampenValue(v) {\n    return 8 * (Math.log(v + 1) - 2);\n}\nconst TRANSITIONS = {\n    DURATION: 0.5,\n    EASE: [\n        0.32,\n        0.72,\n        0,\n        1\n    ]\n};\nconst VELOCITY_THRESHOLD = 0.4;\n// This code comes from https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\nfunction useCallbackRef(callback) {\n    const callbackRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(callback);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        callbackRef.current = callback;\n    });\n    // https://github.com/facebook/react/issues/19240\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(...args)=>callbackRef.current == null ? void 0 : callbackRef.current.call(callbackRef, ...args), []);\n}\nfunction useUncontrolledState({ defaultProp, onChange }) {\n    const uncontrolledState = react__WEBPACK_IMPORTED_MODULE_0__.useState(defaultProp);\n    const [value] = uncontrolledState;\n    const prevValueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n    const handleChange = useCallbackRef(onChange);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (prevValueRef.current !== value) {\n            handleChange(value);\n            prevValueRef.current = value;\n        }\n    }, [\n        value,\n        prevValueRef,\n        handleChange\n    ]);\n    return uncontrolledState;\n}\nfunction useControllableState({ prop, defaultProp, onChange = ()=>{} }) {\n    const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({\n        defaultProp,\n        onChange\n    });\n    const isControlled = prop !== undefined;\n    const value = isControlled ? prop : uncontrolledProp;\n    const handleChange = useCallbackRef(onChange);\n    const setValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextValue)=>{\n        if (isControlled) {\n            const setter = nextValue;\n            const value = typeof nextValue === \"function\" ? setter(prop) : nextValue;\n            if (value !== prop) handleChange(value);\n        } else {\n            setUncontrolledProp(nextValue);\n        }\n    }, [\n        isControlled,\n        prop,\n        setUncontrolledProp,\n        handleChange\n    ]);\n    return [\n        value,\n        setValue\n    ];\n}\nfunction useSnapPoints({ activeSnapPointProp, setActiveSnapPointProp, snapPoints, drawerRef, overlayRef, fadeFromIndex, onSnapPointChange, direction = \"bottom\" }) {\n    const [activeSnapPoint, setActiveSnapPoint] = useControllableState({\n        prop: activeSnapPointProp,\n        defaultProp: snapPoints == null ? void 0 : snapPoints[0],\n        onChange: setActiveSnapPointProp\n    });\n    const isLastSnapPoint = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>activeSnapPoint === (snapPoints == null ? void 0 : snapPoints[snapPoints.length - 1]) || null, [\n        snapPoints,\n        activeSnapPoint\n    ]);\n    const shouldFade = snapPoints && snapPoints.length > 0 && (fadeFromIndex || fadeFromIndex === 0) && !Number.isNaN(fadeFromIndex) && snapPoints[fadeFromIndex] === activeSnapPoint || !snapPoints;\n    const activeSnapPointIndex = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint)=>snapPoint === activeSnapPoint), [\n        snapPoints,\n        activeSnapPoint\n    ]);\n    const snapPointsOffset = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        var _snapPoints_map;\n        return (_snapPoints_map = snapPoints == null ? void 0 : snapPoints.map((snapPoint)=>{\n            const hasWindow = \"undefined\" !== \"undefined\";\n            const isPx = typeof snapPoint === \"string\";\n            let snapPointAsNumber = 0;\n            if (isPx) {\n                snapPointAsNumber = parseInt(snapPoint, 10);\n            }\n            if (isVertical(direction)) {\n                const height = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerHeight : 0;\n                if (hasWindow) {\n                    return direction === \"bottom\" ? window.innerHeight - height : -window.innerHeight + height;\n                }\n                return height;\n            }\n            const width = isPx ? snapPointAsNumber : hasWindow ? snapPoint * window.innerWidth : 0;\n            if (hasWindow) {\n                return direction === \"right\" ? window.innerWidth - width : -window.innerWidth + width;\n            }\n            return width;\n        })) != null ? _snapPoints_map : [];\n    }, [\n        snapPoints\n    ]);\n    const activeSnapPointOffset = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>activeSnapPointIndex !== null ? snapPointsOffset == null ? void 0 : snapPointsOffset[activeSnapPointIndex] : null, [\n        snapPointsOffset,\n        activeSnapPointIndex\n    ]);\n    const snapToPoint = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((dimension)=>{\n        var _snapPointsOffset_findIndex;\n        const newSnapPointIndex = (_snapPointsOffset_findIndex = snapPointsOffset == null ? void 0 : snapPointsOffset.findIndex((snapPointDim)=>snapPointDim === dimension)) != null ? _snapPointsOffset_findIndex : null;\n        onSnapPointChange(newSnapPointIndex);\n        set(drawerRef.current, {\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            transform: isVertical(direction) ? `translate3d(0, ${dimension}px, 0)` : `translate3d(${dimension}px, 0, 0)`\n        });\n        if (snapPointsOffset && newSnapPointIndex !== snapPointsOffset.length - 1 && newSnapPointIndex !== fadeFromIndex) {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n                opacity: \"0\"\n            });\n        } else {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n                opacity: \"1\"\n            });\n        }\n        setActiveSnapPoint(newSnapPointIndex !== null ? snapPoints == null ? void 0 : snapPoints[newSnapPointIndex] : null);\n    }, [\n        drawerRef.current,\n        snapPoints,\n        snapPointsOffset,\n        fadeFromIndex,\n        overlayRef,\n        setActiveSnapPoint\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (activeSnapPoint || activeSnapPointProp) {\n            var _snapPoints_findIndex;\n            const newIndex = (_snapPoints_findIndex = snapPoints == null ? void 0 : snapPoints.findIndex((snapPoint)=>snapPoint === activeSnapPointProp || snapPoint === activeSnapPoint)) != null ? _snapPoints_findIndex : -1;\n            if (snapPointsOffset && newIndex !== -1 && typeof snapPointsOffset[newIndex] === \"number\") {\n                snapToPoint(snapPointsOffset[newIndex]);\n            }\n        }\n    }, [\n        activeSnapPoint,\n        activeSnapPointProp,\n        snapPoints,\n        snapPointsOffset,\n        snapToPoint\n    ]);\n    function onRelease({ draggedDistance, closeDrawer, velocity, dismissible }) {\n        if (fadeFromIndex === undefined) return;\n        const currentPosition = direction === \"bottom\" || direction === \"right\" ? (activeSnapPointOffset != null ? activeSnapPointOffset : 0) - draggedDistance : (activeSnapPointOffset != null ? activeSnapPointOffset : 0) + draggedDistance;\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n        const isFirst = activeSnapPointIndex === 0;\n        const hasDraggedUp = draggedDistance > 0;\n        if (isOverlaySnapPoint) {\n            set(overlayRef.current, {\n                transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n            });\n        }\n        if (velocity > 2 && !hasDraggedUp) {\n            if (dismissible) closeDrawer();\n            else snapToPoint(snapPointsOffset[0]); // snap to initial point\n            return;\n        }\n        if (velocity > 2 && hasDraggedUp && snapPointsOffset && snapPoints) {\n            snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n            return;\n        }\n        // Find the closest snap point to the current position\n        const closestSnapPoint = snapPointsOffset == null ? void 0 : snapPointsOffset.reduce((prev, curr)=>{\n            if (typeof prev !== \"number\" || typeof curr !== \"number\") return prev;\n            return Math.abs(curr - currentPosition) < Math.abs(prev - currentPosition) ? curr : prev;\n        });\n        const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        if (velocity > VELOCITY_THRESHOLD && Math.abs(draggedDistance) < dim * 0.4) {\n            const dragDirection = hasDraggedUp ? 1 : -1; // 1 = up, -1 = down\n            // Don't do anything if we swipe upwards while being on the last snap point\n            if (dragDirection > 0 && isLastSnapPoint) {\n                snapToPoint(snapPointsOffset[snapPoints.length - 1]);\n                return;\n            }\n            if (isFirst && dragDirection < 0 && dismissible) {\n                closeDrawer();\n            }\n            if (activeSnapPointIndex === null) return;\n            snapToPoint(snapPointsOffset[activeSnapPointIndex + dragDirection]);\n            return;\n        }\n        snapToPoint(closestSnapPoint);\n    }\n    function onDrag({ draggedDistance }) {\n        if (activeSnapPointOffset === null) return;\n        const newValue = direction === \"bottom\" || direction === \"right\" ? activeSnapPointOffset - draggedDistance : activeSnapPointOffset + draggedDistance;\n        // Don't do anything if we exceed the last(biggest) snap point\n        if ((direction === \"bottom\" || direction === \"right\") && newValue < snapPointsOffset[snapPointsOffset.length - 1]) {\n            return;\n        }\n        if ((direction === \"top\" || direction === \"left\") && newValue > snapPointsOffset[snapPointsOffset.length - 1]) {\n            return;\n        }\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `translate3d(0, ${newValue}px, 0)` : `translate3d(${newValue}px, 0, 0)`\n        });\n    }\n    function getPercentageDragged(absDraggedDistance, isDraggingDown) {\n        if (!snapPoints || typeof activeSnapPointIndex !== \"number\" || !snapPointsOffset || fadeFromIndex === undefined) return null;\n        // If this is true we are dragging to a snap point that is supposed to have an overlay\n        const isOverlaySnapPoint = activeSnapPointIndex === fadeFromIndex - 1;\n        const isOverlaySnapPointOrHigher = activeSnapPointIndex >= fadeFromIndex;\n        if (isOverlaySnapPointOrHigher && isDraggingDown) {\n            return 0;\n        }\n        // Don't animate, but still use this one if we are dragging away from the overlaySnapPoint\n        if (isOverlaySnapPoint && !isDraggingDown) return 1;\n        if (!shouldFade && !isOverlaySnapPoint) return null;\n        // Either fadeFrom index or the one before\n        const targetSnapPointIndex = isOverlaySnapPoint ? activeSnapPointIndex + 1 : activeSnapPointIndex - 1;\n        // Get the distance from overlaySnapPoint to the one before or vice-versa to calculate the opacity percentage accordingly\n        const snapPointDistance = isOverlaySnapPoint ? snapPointsOffset[targetSnapPointIndex] - snapPointsOffset[targetSnapPointIndex - 1] : snapPointsOffset[targetSnapPointIndex + 1] - snapPointsOffset[targetSnapPointIndex];\n        const percentageDragged = absDraggedDistance / Math.abs(snapPointDistance);\n        if (isOverlaySnapPoint) {\n            return 1 - percentageDragged;\n        } else {\n            return percentageDragged;\n        }\n    }\n    return {\n        isLastSnapPoint,\n        activeSnapPoint,\n        shouldFade,\n        getPercentageDragged,\n        setActiveSnapPoint,\n        activeSnapPointIndex,\n        onRelease,\n        onDrag,\n        snapPointsOffset\n    };\n}\nconst CLOSE_THRESHOLD = 0.25;\nconst SCROLL_LOCK_TIMEOUT = 100;\nconst BORDER_RADIUS = 8;\nconst NESTED_DISPLACEMENT = 16;\nconst WINDOW_TOP_OFFSET = 26;\nconst DRAG_CLASS = \"vaul-dragging\";\nfunction Root({ open: openProp, onOpenChange, children, shouldScaleBackground, onDrag: onDragProp, onRelease: onReleaseProp, snapPoints, nested = false, setBackgroundColorOnScale = true, closeThreshold = CLOSE_THRESHOLD, scrollLockTimeout = SCROLL_LOCK_TIMEOUT, dismissible = true, handleOnly = false, fadeFromIndex = snapPoints && snapPoints.length - 1, activeSnapPoint: activeSnapPointProp, setActiveSnapPoint: setActiveSnapPointProp, fixed, modal = true, onClose, noBodyStyles, direction = \"bottom\", preventScrollRestoration = true, disablePreventScroll = false }) {\n    var _drawerRef_current;\n    const [isOpen = false, setIsOpen] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [hasBeenOpened, setHasBeenOpened] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    // Not visible = translateY(100%)\n    const [visible, setVisible] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [isDragging, setIsDragging] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [justReleased, setJustReleased] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const overlayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const openTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dragStartTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dragEndTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const lastTimeDragPrevented = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isAllowedToDrag = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const nestedOpenChangeTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const pointerStart = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const keyboardIsOpen = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const previousDiffFromInitial = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const drawerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const drawerHeightRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0);\n    const initialDrawerHeight = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const onSnapPointChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((activeSnapPointIndex)=>{\n        // Change openTime ref when we reach the last snap point to prevent dragging for 500ms incase it's scrollable.\n        if (snapPoints && activeSnapPointIndex === snapPointsOffset.length - 1) openTime.current = new Date();\n    }, []);\n    const { activeSnapPoint, activeSnapPointIndex, setActiveSnapPoint, onRelease: onReleaseSnapPoints, snapPointsOffset, onDrag: onDragSnapPoints, shouldFade, getPercentageDragged: getSnapPointsPercentageDragged } = useSnapPoints({\n        snapPoints,\n        activeSnapPointProp,\n        setActiveSnapPointProp,\n        drawerRef,\n        fadeFromIndex,\n        overlayRef,\n        onSnapPointChange,\n        direction\n    });\n    usePreventScroll({\n        isDisabled: !isOpen || isDragging || !modal || justReleased || !hasBeenOpened || disablePreventScroll\n    });\n    const { restorePositionSetting } = usePositionFixed({\n        isOpen,\n        modal,\n        nested,\n        hasBeenOpened,\n        preventScrollRestoration,\n        noBodyStyles\n    });\n    function getScale() {\n        return (window.innerWidth - WINDOW_TOP_OFFSET) / window.innerWidth;\n    }\n    function onPress(event) {\n        var _drawerRef_current;\n        if (!dismissible && !snapPoints) return;\n        if (drawerRef.current && !drawerRef.current.contains(event.target)) return;\n        drawerHeightRef.current = ((_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.getBoundingClientRect().height) || 0;\n        setIsDragging(true);\n        dragStartTime.current = new Date();\n        // iOS doesn't trigger mouseUp after scrolling so we need to listen to touched in order to disallow dragging\n        if (isIOS()) {\n            window.addEventListener(\"touchend\", ()=>isAllowedToDrag.current = false, {\n                once: true\n            });\n        }\n        // Ensure we maintain correct pointer capture even when going outside of the drawer\n        event.target.setPointerCapture(event.pointerId);\n        pointerStart.current = isVertical(direction) ? event.clientY : event.clientX;\n    }\n    function shouldDrag(el, isDraggingInDirection) {\n        var _window_getSelection;\n        let element = el;\n        const highlightedText = (_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString();\n        const swipeAmount = drawerRef.current ? getTranslate(drawerRef.current, direction) : null;\n        const date = new Date();\n        if (element.hasAttribute(\"data-vaul-no-drag\") || element.closest(\"[data-vaul-no-drag]\")) {\n            return false;\n        }\n        if (direction === \"right\" || direction === \"left\") {\n            return true;\n        }\n        // Allow scrolling when animating\n        if (openTime.current && date.getTime() - openTime.current.getTime() < 500) {\n            return false;\n        }\n        if (swipeAmount !== null) {\n            if (direction === \"bottom\" ? swipeAmount > 0 : swipeAmount < 0) {\n                return true;\n            }\n        }\n        // Don't drag if there's highlighted text\n        if (highlightedText && highlightedText.length > 0) {\n            return false;\n        }\n        // Disallow dragging if drawer was scrolled within `scrollLockTimeout`\n        if (lastTimeDragPrevented.current && date.getTime() - lastTimeDragPrevented.current.getTime() < scrollLockTimeout && swipeAmount === 0) {\n            lastTimeDragPrevented.current = date;\n            return false;\n        }\n        if (isDraggingInDirection) {\n            lastTimeDragPrevented.current = date;\n            // We are dragging down so we should allow scrolling\n            return false;\n        }\n        // Keep climbing up the DOM tree as long as there's a parent\n        while(element){\n            // Check if the element is scrollable\n            if (element.scrollHeight > element.clientHeight) {\n                if (element.scrollTop !== 0) {\n                    lastTimeDragPrevented.current = new Date();\n                    // The element is scrollable and not scrolled to the top, so don't drag\n                    return false;\n                }\n                if (element.getAttribute(\"role\") === \"dialog\") {\n                    return true;\n                }\n            }\n            // Move up to the parent element\n            element = element.parentNode;\n        }\n        // No scrollable parents not scrolled to the top found, so drag\n        return true;\n    }\n    function onDrag(event) {\n        if (!drawerRef.current) {\n            return;\n        }\n        // We need to know how much of the drawer has been dragged in percentages so that we can transform background accordingly\n        if (isDragging) {\n            const directionMultiplier = direction === \"bottom\" || direction === \"right\" ? 1 : -1;\n            const draggedDistance = (pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX)) * directionMultiplier;\n            const isDraggingInDirection = draggedDistance > 0;\n            // Pre condition for disallowing dragging in the close direction.\n            const noCloseSnapPointsPreCondition = snapPoints && !dismissible && !isDraggingInDirection;\n            // Disallow dragging down to close when first snap point is the active one and dismissible prop is set to false.\n            if (noCloseSnapPointsPreCondition && activeSnapPointIndex === 0) return;\n            // We need to capture last time when drag with scroll was triggered and have a timeout between\n            const absDraggedDistance = Math.abs(draggedDistance);\n            const wrapper = document.querySelector(\"[vaul-drawer-wrapper]\");\n            // Calculate the percentage dragged, where 1 is the closed position\n            let percentageDragged = absDraggedDistance / drawerHeightRef.current;\n            const snapPointPercentageDragged = getSnapPointsPercentageDragged(absDraggedDistance, isDraggingInDirection);\n            if (snapPointPercentageDragged !== null) {\n                percentageDragged = snapPointPercentageDragged;\n            }\n            // Disallow close dragging beyond the smallest snap point.\n            if (noCloseSnapPointsPreCondition && percentageDragged >= 1) {\n                return;\n            }\n            if (!isAllowedToDrag.current && !shouldDrag(event.target, isDraggingInDirection)) return;\n            drawerRef.current.classList.add(DRAG_CLASS);\n            // If shouldDrag gave true once after pressing down on the drawer, we set isAllowedToDrag to true and it will remain true until we let go, there's no reason to disable dragging mid way, ever, and that's the solution to it\n            isAllowedToDrag.current = true;\n            set(drawerRef.current, {\n                transition: \"none\"\n            });\n            set(overlayRef.current, {\n                transition: \"none\"\n            });\n            if (snapPoints) {\n                onDragSnapPoints({\n                    draggedDistance\n                });\n            }\n            // Run this only if snapPoints are not defined or if we are at the last snap point (highest one)\n            if (isDraggingInDirection && !snapPoints) {\n                const dampenedDraggedDistance = dampenValue(draggedDistance);\n                const translateValue = Math.min(dampenedDraggedDistance * -1, 0) * directionMultiplier;\n                set(drawerRef.current, {\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n                return;\n            }\n            const opacityValue = 1 - percentageDragged;\n            if (shouldFade || fadeFromIndex && activeSnapPointIndex === fadeFromIndex - 1) {\n                onDragProp == null ? void 0 : onDragProp(event, percentageDragged);\n                set(overlayRef.current, {\n                    opacity: `${opacityValue}`,\n                    transition: \"none\"\n                }, true);\n            }\n            if (wrapper && overlayRef.current && shouldScaleBackground) {\n                // Calculate percentageDragged as a fraction (0 to 1)\n                const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);\n                const borderRadiusValue = 8 - percentageDragged * 8;\n                const translateValue = Math.max(0, 14 - percentageDragged * 14);\n                set(wrapper, {\n                    borderRadius: `${borderRadiusValue}px`,\n                    transform: isVertical(direction) ? `scale(${scaleValue}) translate3d(0, ${translateValue}px, 0)` : `scale(${scaleValue}) translate3d(${translateValue}px, 0, 0)`,\n                    transition: \"none\"\n                }, true);\n            }\n            if (!snapPoints) {\n                const translateValue = absDraggedDistance * directionMultiplier;\n                set(drawerRef.current, {\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n            }\n        }\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            scaleBackground(false);\n            restorePositionSetting();\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _window_visualViewport;\n        function onVisualViewportChange() {\n            if (!drawerRef.current) return;\n            const focusedElement = document.activeElement;\n            if (isInput(focusedElement) || keyboardIsOpen.current) {\n                var _window_visualViewport;\n                const visualViewportHeight = ((_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.height) || 0;\n                // This is the height of the keyboard\n                let diffFromInitial = window.innerHeight - visualViewportHeight;\n                const drawerHeight = drawerRef.current.getBoundingClientRect().height || 0;\n                if (!initialDrawerHeight.current) {\n                    initialDrawerHeight.current = drawerHeight;\n                }\n                const offsetFromTop = drawerRef.current.getBoundingClientRect().top;\n                // visualViewport height may change due to some subtle changes to the keyboard. Checking if the height changed by 60 or more will make sure that they keyboard really changed its open state.\n                if (Math.abs(previousDiffFromInitial.current - diffFromInitial) > 60) {\n                    keyboardIsOpen.current = !keyboardIsOpen.current;\n                }\n                if (snapPoints && snapPoints.length > 0 && snapPointsOffset && activeSnapPointIndex) {\n                    const activeSnapPointHeight = snapPointsOffset[activeSnapPointIndex] || 0;\n                    diffFromInitial += activeSnapPointHeight;\n                }\n                previousDiffFromInitial.current = diffFromInitial;\n                // We don't have to change the height if the input is in view, when we are here we are in the opened keyboard state so we can correctly check if the input is in view\n                if (drawerHeight > visualViewportHeight || keyboardIsOpen.current) {\n                    const height = drawerRef.current.getBoundingClientRect().height;\n                    let newDrawerHeight = height;\n                    if (height > visualViewportHeight) {\n                        newDrawerHeight = visualViewportHeight - WINDOW_TOP_OFFSET;\n                    }\n                    // When fixed, don't move the drawer upwards if there's space, but rather only change it's height so it's fully scrollable when the keyboard is open\n                    if (fixed) {\n                        drawerRef.current.style.height = `${height - Math.max(diffFromInitial, 0)}px`;\n                    } else {\n                        drawerRef.current.style.height = `${Math.max(newDrawerHeight, visualViewportHeight - offsetFromTop)}px`;\n                    }\n                } else {\n                    drawerRef.current.style.height = `${initialDrawerHeight.current}px`;\n                }\n                if (snapPoints && snapPoints.length > 0 && !keyboardIsOpen.current) {\n                    drawerRef.current.style.bottom = `0px`;\n                } else {\n                    // Negative bottom value would never make sense\n                    drawerRef.current.style.bottom = `${Math.max(diffFromInitial, 0)}px`;\n                }\n            }\n        }\n        (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.addEventListener(\"resize\", onVisualViewportChange);\n        return ()=>{\n            var _window_visualViewport;\n            return (_window_visualViewport = window.visualViewport) == null ? void 0 : _window_visualViewport.removeEventListener(\"resize\", onVisualViewportChange);\n        };\n    }, [\n        activeSnapPointIndex,\n        snapPoints,\n        snapPointsOffset\n    ]);\n    function closeDrawer() {\n        if (!drawerRef.current) return;\n        cancelDrag();\n        onClose == null ? void 0 : onClose();\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `translate3d(0, ${direction === \"bottom\" ? \"100%\" : \"-100%\"}, 0)` : `translate3d(${direction === \"right\" ? \"100%\" : \"-100%\"}, 0, 0)`,\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n        });\n        set(overlayRef.current, {\n            opacity: \"0\",\n            transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n        });\n        scaleBackground(false);\n        setTimeout(()=>{\n            setVisible(false);\n            setIsOpen(false);\n        }, 300);\n        setTimeout(()=>{\n            // reset(document.documentElement, 'scrollBehavior');\n            if (snapPoints) {\n                setActiveSnapPoint(snapPoints[0]);\n            }\n        }, TRANSITIONS.DURATION * 1000); // seconds to ms\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!isOpen && shouldScaleBackground) {\n            // Can't use `onAnimationEnd` as the component will be invisible by then\n            const id = setTimeout(()=>{\n                reset(document.body);\n            }, 200);\n            return ()=>clearTimeout(id);\n        }\n    }, [\n        isOpen,\n        shouldScaleBackground\n    ]);\n    // LayoutEffect to prevent extra render where openProp and isOpen are not synced yet\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n        if (openProp) {\n            setIsOpen(true);\n            setHasBeenOpened(true);\n        } else {\n            closeDrawer();\n        }\n    }, [\n        openProp\n    ]);\n    // This can be done much better\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (mounted) {\n            onOpenChange == null ? void 0 : onOpenChange(isOpen);\n        }\n    }, [\n        isOpen\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    function resetDrawer() {\n        if (!drawerRef.current) return;\n        const wrapper = document.querySelector(\"[vaul-drawer-wrapper]\");\n        const currentSwipeAmount = getTranslate(drawerRef.current, direction);\n        set(drawerRef.current, {\n            transform: \"translate3d(0, 0, 0)\",\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n        });\n        set(overlayRef.current, {\n            transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            opacity: \"1\"\n        });\n        // Don't reset background if swiped upwards\n        if (shouldScaleBackground && currentSwipeAmount && currentSwipeAmount > 0 && isOpen) {\n            set(wrapper, {\n                borderRadius: `${BORDER_RADIUS}px`,\n                overflow: \"hidden\",\n                ...isVertical(direction) ? {\n                    transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n                    transformOrigin: \"top\"\n                } : {\n                    transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n                    transformOrigin: \"left\"\n                },\n                transitionProperty: \"transform, border-radius\",\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n            }, true);\n        }\n    }\n    function cancelDrag() {\n        if (!isDragging || !drawerRef.current) return;\n        drawerRef.current.classList.remove(DRAG_CLASS);\n        isAllowedToDrag.current = false;\n        setIsDragging(false);\n        dragEndTime.current = new Date();\n    }\n    function onRelease(event) {\n        if (!isDragging || !drawerRef.current) return;\n        drawerRef.current.classList.remove(DRAG_CLASS);\n        isAllowedToDrag.current = false;\n        setIsDragging(false);\n        dragEndTime.current = new Date();\n        const swipeAmount = getTranslate(drawerRef.current, direction);\n        if (!shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount)) return;\n        if (dragStartTime.current === null) return;\n        const timeTaken = dragEndTime.current.getTime() - dragStartTime.current.getTime();\n        const distMoved = pointerStart.current - (isVertical(direction) ? event.clientY : event.clientX);\n        const velocity = Math.abs(distMoved) / timeTaken;\n        if (velocity > 0.05) {\n            // `justReleased` is needed to prevent the drawer from focusing on an input when the drag ends, as it's not the intent most of the time.\n            setJustReleased(true);\n            setTimeout(()=>{\n                setJustReleased(false);\n            }, 200);\n        }\n        if (snapPoints) {\n            const directionMultiplier = direction === \"bottom\" || direction === \"right\" ? 1 : -1;\n            onReleaseSnapPoints({\n                draggedDistance: distMoved * directionMultiplier,\n                closeDrawer,\n                velocity,\n                dismissible\n            });\n            onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n            return;\n        }\n        // Moved upwards, don't do anything\n        if (direction === \"bottom\" || direction === \"right\" ? distMoved > 0 : distMoved < 0) {\n            resetDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n            return;\n        }\n        if (velocity > VELOCITY_THRESHOLD) {\n            closeDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n            return;\n        }\n        var _drawerRef_current_getBoundingClientRect_height;\n        const visibleDrawerHeight = Math.min((_drawerRef_current_getBoundingClientRect_height = drawerRef.current.getBoundingClientRect().height) != null ? _drawerRef_current_getBoundingClientRect_height : 0, window.innerHeight);\n        if (swipeAmount >= visibleDrawerHeight * closeThreshold) {\n            closeDrawer();\n            onReleaseProp == null ? void 0 : onReleaseProp(event, false);\n            return;\n        }\n        onReleaseProp == null ? void 0 : onReleaseProp(event, true);\n        resetDrawer();\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Trigger enter animation without using CSS animation\n        if (isOpen) {\n            set(document.documentElement, {\n                scrollBehavior: \"auto\"\n            });\n            openTime.current = new Date();\n            scaleBackground(true);\n        }\n    }, [\n        isOpen\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (drawerRef.current && visible) {\n            var _drawerRef_current;\n            // Find all scrollable elements inside our drawer and assign a class to it so that we can disable overflow when dragging to prevent pointermove not being captured\n            const children = drawerRef == null ? void 0 : (_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.querySelectorAll(\"*\");\n            children == null ? void 0 : children.forEach((child)=>{\n                const htmlChild = child;\n                if (htmlChild.scrollHeight > htmlChild.clientHeight || htmlChild.scrollWidth > htmlChild.clientWidth) {\n                    htmlChild.classList.add(\"vaul-scrollable\");\n                }\n            });\n        }\n    }, [\n        visible\n    ]);\n    function scaleBackground(open) {\n        const wrapper = document.querySelector(\"[vaul-drawer-wrapper]\");\n        if (!wrapper || !shouldScaleBackground) return;\n        if (open) {\n            if (setBackgroundColorOnScale) {\n                if (!noBodyStyles) {\n                    // setting original styles initially\n                    set(document.body, {\n                        background: document.body.style.backgroundColor || document.body.style.background\n                    });\n                    // setting body styles, with cache ignored, so that we can get correct original styles in reset\n                    set(document.body, {\n                        background: \"black\"\n                    }, true);\n                }\n            }\n            set(wrapper, {\n                borderRadius: `${BORDER_RADIUS}px`,\n                overflow: \"hidden\",\n                ...isVertical(direction) ? {\n                    transform: `scale(${getScale()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,\n                    transformOrigin: \"top\"\n                } : {\n                    transform: `scale(${getScale()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,\n                    transformOrigin: \"left\"\n                },\n                transitionProperty: \"transform, border-radius\",\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n            });\n        } else {\n            // Exit\n            reset(wrapper, \"overflow\");\n            reset(wrapper, \"transform\");\n            reset(wrapper, \"borderRadius\");\n            set(wrapper, {\n                transitionProperty: \"transform, border-radius\",\n                transitionDuration: `${TRANSITIONS.DURATION}s`,\n                transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`\n            });\n        }\n    }\n    function onNestedOpenChange(o) {\n        const scale = o ? (window.innerWidth - NESTED_DISPLACEMENT) / window.innerWidth : 1;\n        const y = o ? -NESTED_DISPLACEMENT : 0;\n        if (nestedOpenChangeTimer.current) {\n            window.clearTimeout(nestedOpenChangeTimer.current);\n        }\n        set(drawerRef.current, {\n            transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n            transform: `scale(${scale}) translate3d(0, ${y}px, 0)`\n        });\n        if (!o && drawerRef.current) {\n            nestedOpenChangeTimer.current = setTimeout(()=>{\n                const translateValue = getTranslate(drawerRef.current, direction);\n                set(drawerRef.current, {\n                    transition: \"none\",\n                    transform: isVertical(direction) ? `translate3d(0, ${translateValue}px, 0)` : `translate3d(${translateValue}px, 0, 0)`\n                });\n            }, 500);\n        }\n    }\n    function onNestedDrag(event, percentageDragged) {\n        if (percentageDragged < 0) return;\n        const initialDim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        const initialScale = (initialDim - NESTED_DISPLACEMENT) / initialDim;\n        const newScale = initialScale + percentageDragged * (1 - initialScale);\n        const newTranslate = -NESTED_DISPLACEMENT + percentageDragged * NESTED_DISPLACEMENT;\n        set(drawerRef.current, {\n            transform: isVertical(direction) ? `scale(${newScale}) translate3d(0, ${newTranslate}px, 0)` : `scale(${newScale}) translate3d(${newTranslate}px, 0, 0)`,\n            transition: \"none\"\n        });\n    }\n    function onNestedRelease(event, o) {\n        const dim = isVertical(direction) ? window.innerHeight : window.innerWidth;\n        const scale = o ? (dim - NESTED_DISPLACEMENT) / dim : 1;\n        const translate = o ? -NESTED_DISPLACEMENT : 0;\n        if (o) {\n            set(drawerRef.current, {\n                transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(\",\")})`,\n                transform: isVertical(direction) ? `scale(${scale}) translate3d(0, ${translate}px, 0)` : `scale(${scale}) translate3d(${translate}px, 0, 0)`\n            });\n        }\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Root, {\n        modal: modal,\n        onOpenChange: (o)=>{\n            if (openProp !== undefined) {\n                onOpenChange == null ? void 0 : onOpenChange(o);\n                return;\n            }\n            if (!o) {\n                closeDrawer();\n            } else {\n                setHasBeenOpened(true);\n                setIsOpen(o);\n            }\n        },\n        open: isOpen\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DrawerContext.Provider, {\n        value: {\n            visible,\n            activeSnapPoint,\n            snapPoints,\n            setActiveSnapPoint,\n            drawerRef,\n            overlayRef,\n            scaleBackground,\n            onOpenChange,\n            onPress,\n            setVisible,\n            onRelease,\n            onDrag,\n            dismissible,\n            handleOnly,\n            isOpen,\n            isDragging,\n            shouldFade,\n            closeDrawer,\n            onNestedDrag,\n            onNestedOpenChange,\n            onNestedRelease,\n            keyboardIsOpen,\n            openProp,\n            modal,\n            snapPointsOffset,\n            direction\n        }\n    }, children));\n}\nconst LONG_HANDLE_PRESS_TIMEOUT = 250;\nconst DOUBLE_TAP_TIMEOUT = 120;\nconst Handle = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ preventCycle = false, children, ...rest }, ref) {\n    const { visible, closeDrawer, isDragging, snapPoints, activeSnapPoint, setActiveSnapPoint, dismissible, handleOnly, onPress, onDrag } = useDrawerContext();\n    const closeTimeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const shouldCancelInteractionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    function handleStartCycle() {\n        // Stop if this is the second click of a double click\n        if (shouldCancelInteractionRef.current) {\n            handleCancelInteraction();\n            return;\n        }\n        window.setTimeout(()=>{\n            handleCycleSnapPoints();\n        }, DOUBLE_TAP_TIMEOUT);\n    }\n    function handleCycleSnapPoints() {\n        // Prevent accidental taps while resizing drawer\n        if (isDragging || preventCycle || shouldCancelInteractionRef.current) {\n            handleCancelInteraction();\n            return;\n        }\n        // Make sure to clear the timeout id if the user releases the handle before the cancel timeout\n        handleCancelInteraction();\n        if ((!snapPoints || snapPoints.length === 0) && dismissible) {\n            closeDrawer();\n            return;\n        }\n        const isLastSnapPoint = activeSnapPoint === snapPoints[snapPoints.length - 1];\n        if (isLastSnapPoint && dismissible) {\n            closeDrawer();\n            return;\n        }\n        const currentSnapIndex = snapPoints.findIndex((point)=>point === activeSnapPoint);\n        if (currentSnapIndex === -1) return; // activeSnapPoint not found in snapPoints\n        const nextSnapPoint = snapPoints[currentSnapIndex + 1];\n        setActiveSnapPoint(nextSnapPoint);\n    }\n    function handleStartInteraction() {\n        closeTimeoutIdRef.current = window.setTimeout(()=>{\n            // Cancel click interaction on a long press\n            shouldCancelInteractionRef.current = true;\n        }, LONG_HANDLE_PRESS_TIMEOUT);\n    }\n    function handleCancelInteraction() {\n        window.clearTimeout(closeTimeoutIdRef.current);\n        shouldCancelInteractionRef.current = false;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        onClick: handleStartCycle,\n        onDoubleClick: ()=>{\n            shouldCancelInteractionRef.current = true;\n            closeDrawer();\n        },\n        onPointerCancel: handleCancelInteraction,\n        onPointerDown: (e)=>{\n            if (handleOnly) onPress(e);\n            handleStartInteraction();\n        },\n        onPointerMove: (e)=>{\n            if (handleOnly) onDrag(e);\n        },\n        // onPointerUp is already handled by the content component\n        ref: ref,\n        \"vaul-drawer-visible\": visible ? \"true\" : \"false\",\n        \"vaul-handle\": \"\",\n        \"aria-hidden\": \"true\",\n        ...rest\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        \"vaul-handle-hitarea\": \"\",\n        \"aria-hidden\": \"true\"\n    }, children));\n});\nHandle.displayName = \"Drawer.Handle\";\nconst Overlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ children, ...rest }, ref) {\n    const { overlayRef, snapPoints, onRelease, shouldFade, isOpen, visible } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, overlayRef);\n    const hasSnapPoints = snapPoints && snapPoints.length > 0;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Overlay, {\n        onMouseUp: onRelease,\n        ref: composedRef,\n        \"vaul-drawer-visible\": visible ? \"true\" : \"false\",\n        \"vaul-overlay\": \"\",\n        \"vaul-snap-points\": isOpen && hasSnapPoints ? \"true\" : \"false\",\n        \"vaul-snap-points-overlay\": isOpen && shouldFade ? \"true\" : \"false\",\n        ...rest\n    });\n});\nOverlay.displayName = \"Drawer.Overlay\";\nconst Content = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ onOpenAutoFocus, onPointerDownOutside, onAnimationEnd, style, ...rest }, ref) {\n    const { drawerRef, onPress, onRelease, onDrag, dismissible, keyboardIsOpen, snapPointsOffset, visible, closeDrawer, modal, openProp, onOpenChange, setVisible, handleOnly, direction } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, drawerRef);\n    const pointerStartRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const wasBeyondThePointRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isDeltaInDirection = (delta, direction, threshold = 0)=>{\n        if (wasBeyondThePointRef.current) return true;\n        const deltaY = Math.abs(delta.y);\n        const deltaX = Math.abs(delta.x);\n        const isDeltaX = deltaX > deltaY;\n        const dFactor = [\n            \"bottom\",\n            \"right\"\n        ].includes(direction) ? 1 : -1;\n        if (direction === \"left\" || direction === \"right\") {\n            const isReverseDirection = delta.x * dFactor < 0;\n            if (!isReverseDirection && deltaX >= 0 && deltaX <= threshold) {\n                return isDeltaX;\n            }\n        } else {\n            const isReverseDirection = delta.y * dFactor < 0;\n            if (!isReverseDirection && deltaY >= 0 && deltaY <= threshold) {\n                return !isDeltaX;\n            }\n        }\n        wasBeyondThePointRef.current = true;\n        return true;\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Trigger enter animation without using CSS animation\n        setVisible(true);\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Content, {\n        \"vaul-drawer\": \"\",\n        \"vaul-drawer-direction\": direction,\n        \"vaul-drawer-visible\": visible ? \"true\" : \"false\",\n        ...rest,\n        ref: composedRef,\n        style: snapPointsOffset && snapPointsOffset.length > 0 ? {\n            \"--snap-point-height\": `${snapPointsOffset[0]}px`,\n            ...style\n        } : style,\n        onOpenAutoFocus: (e)=>{\n            if (onOpenAutoFocus) {\n                onOpenAutoFocus(e);\n            } else {\n                var _drawerRef_current;\n                e.preventDefault();\n                (_drawerRef_current = drawerRef.current) == null ? void 0 : _drawerRef_current.focus();\n            }\n        },\n        onPointerDown: (event)=>{\n            if (handleOnly) return;\n            rest.onPointerDown == null ? void 0 : rest.onPointerDown.call(rest, event);\n            pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n            };\n            onPress(event);\n        },\n        onPointerDownOutside: (e)=>{\n            onPointerDownOutside == null ? void 0 : onPointerDownOutside(e);\n            if (!modal || e.defaultPrevented) {\n                e.preventDefault();\n                return;\n            }\n            if (keyboardIsOpen.current) {\n                keyboardIsOpen.current = false;\n            }\n            e.preventDefault();\n            onOpenChange == null ? void 0 : onOpenChange(false);\n            if (!dismissible || openProp !== undefined) {\n                return;\n            }\n            closeDrawer();\n        },\n        onFocusOutside: (e)=>{\n            if (!modal) {\n                e.preventDefault();\n                return;\n            }\n        },\n        onEscapeKeyDown: (e)=>{\n            if (!modal) {\n                e.preventDefault();\n                return;\n            }\n        },\n        onPointerMove: (event)=>{\n            if (handleOnly) return;\n            rest.onPointerMove == null ? void 0 : rest.onPointerMove.call(rest, event);\n            if (!pointerStartRef.current) return;\n            const yPosition = event.clientY - pointerStartRef.current.y;\n            const xPosition = event.clientX - pointerStartRef.current.x;\n            const swipeStartThreshold = event.pointerType === \"touch\" ? 10 : 2;\n            const delta = {\n                x: xPosition,\n                y: yPosition\n            };\n            const isAllowedToSwipe = isDeltaInDirection(delta, direction, swipeStartThreshold);\n            if (isAllowedToSwipe) onDrag(event);\n            else if (Math.abs(xPosition) > swipeStartThreshold || Math.abs(yPosition) > swipeStartThreshold) {\n                pointerStartRef.current = null;\n            }\n        },\n        onPointerUp: (event)=>{\n            rest.onPointerUp == null ? void 0 : rest.onPointerUp.call(rest, event);\n            pointerStartRef.current = null;\n            wasBeyondThePointRef.current = false;\n            onRelease(event);\n        }\n    });\n});\nContent.displayName = \"Drawer.Content\";\nfunction NestedRoot({ onDrag, onOpenChange, ...rest }) {\n    const { onNestedDrag, onNestedOpenChange, onNestedRelease } = useDrawerContext();\n    if (!onNestedDrag) {\n        throw new Error(\"Drawer.NestedRoot must be placed in another drawer\");\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Root, {\n        nested: true,\n        onClose: ()=>{\n            onNestedOpenChange(false);\n        },\n        onDrag: (e, p)=>{\n            onNestedDrag(e, p);\n            onDrag == null ? void 0 : onDrag(e, p);\n        },\n        onOpenChange: (o)=>{\n            if (o) {\n                onNestedOpenChange(o);\n            }\n            onOpenChange == null ? void 0 : onOpenChange(o);\n        },\n        onRelease: onNestedRelease,\n        ...rest\n    });\n}\nconst Drawer = {\n    Root,\n    NestedRoot,\n    Content,\n    Handle,\n    Overlay,\n    Trigger: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Trigger,\n    Portal: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Portal,\n    Close: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Close,\n    Title: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Title,\n    Description: _radix_ui_react_dialog__WEBPACK_IMPORTED_MODULE_1__.Description\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLElBQUl3QixNQUFNO0lBQ3BCO0lBQ0EsT0FBTyxXQUFXLEdBQUdwQyxnREFBNEIsQ0FBQzhRLE1BQU07UUFDcERqSSxRQUFRO1FBQ1IySSxTQUFTO1lBQ0wzUSxtQkFBbUI7UUFDdkI7UUFDQUYsUUFBUSxDQUFDb0UsR0FBRzJWO1lBQ1I5WixhQUFhbUUsR0FBRzJWO1lBQ2hCL1osVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT29FLEdBQUcyVjtRQUN4QztRQUNBL1ksY0FBYyxDQUFDcVY7WUFDWCxJQUFJQSxHQUFHO2dCQUNIblcsbUJBQW1CbVc7WUFDdkI7WUFDQXJWLGdCQUFnQixPQUFPLEtBQUssSUFBSUEsYUFBYXFWO1FBQ2pEO1FBQ0F0VyxXQUFXSTtRQUNYLEdBQUcrVyxJQUFJO0lBQ1g7QUFDSjtBQUNBLE1BQU04QyxTQUFTO0lBQ1g3SjtJQUNBMko7SUFDQXhCO0lBQ0F2QjtJQUNBbUI7SUFDQStCLFNBQVM5YSwyREFBdUI7SUFDaEMrYSxRQUFRL2EsMERBQXNCO0lBQzlCZ2IsT0FBT2hiLHlEQUFxQjtJQUM1QmliLE9BQU9qYix5REFBcUI7SUFDNUJrYixhQUFhbGIsK0RBQTJCO0FBQzVDO0FBRWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmxvZy8uL25vZGVfbW9kdWxlcy92YXVsL2Rpc3QvaW5kZXgubWpzPzRhOWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuZnVuY3Rpb24gX19pbnNlcnRDU1MoY29kZSkge1xuICBpZiAoIWNvZGUgfHwgdHlwZW9mIGRvY3VtZW50ID09ICd1bmRlZmluZWQnKSByZXR1cm5cbiAgbGV0IGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF1cbiAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKVxuICA7c3R5bGUuc3R5bGVTaGVldCA/IChzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb2RlKSA6IHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvZGUpKVxufVxuXG5pbXBvcnQgKiBhcyBEaWFsb2dQcmltaXRpdmUgZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWRpYWxvZyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IERyYXdlckNvbnRleHQgPSBSZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0KHtcbiAgICBkcmF3ZXJSZWY6IHtcbiAgICAgICAgY3VycmVudDogbnVsbFxuICAgIH0sXG4gICAgb3ZlcmxheVJlZjoge1xuICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgfSxcbiAgICBzY2FsZUJhY2tncm91bmQ6ICgpPT57fSxcbiAgICBvblByZXNzOiAoKT0+e30sXG4gICAgb25SZWxlYXNlOiAoKT0+e30sXG4gICAgb25EcmFnOiAoKT0+e30sXG4gICAgb25OZXN0ZWREcmFnOiAoKT0+e30sXG4gICAgb25OZXN0ZWRPcGVuQ2hhbmdlOiAoKT0+e30sXG4gICAgb25OZXN0ZWRSZWxlYXNlOiAoKT0+e30sXG4gICAgb3BlblByb3A6IHVuZGVmaW5lZCxcbiAgICBkaXNtaXNzaWJsZTogZmFsc2UsXG4gICAgaGFuZGxlT25seTogZmFsc2UsXG4gICAgaXNPcGVuOiBmYWxzZSxcbiAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICBrZXlib2FyZElzT3Blbjoge1xuICAgICAgICBjdXJyZW50OiBmYWxzZVxuICAgIH0sXG4gICAgc25hcFBvaW50c09mZnNldDogbnVsbCxcbiAgICBzbmFwUG9pbnRzOiBudWxsLFxuICAgIG1vZGFsOiBmYWxzZSxcbiAgICBzaG91bGRGYWRlOiBmYWxzZSxcbiAgICBhY3RpdmVTbmFwUG9pbnQ6IG51bGwsXG4gICAgb25PcGVuQ2hhbmdlOiAoKT0+e30sXG4gICAgc2V0QWN0aXZlU25hcFBvaW50OiAoKT0+e30sXG4gICAgdmlzaWJsZTogZmFsc2UsXG4gICAgY2xvc2VEcmF3ZXI6ICgpPT57fSxcbiAgICBzZXRWaXNpYmxlOiAoKT0+e30sXG4gICAgZGlyZWN0aW9uOiAnYm90dG9tJ1xufSk7XG5jb25zdCB1c2VEcmF3ZXJDb250ZXh0ID0gKCk9PntcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChEcmF3ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VEcmF3ZXJDb250ZXh0IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBEcmF3ZXIuUm9vdCcpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn07XG5cbl9faW5zZXJ0Q1NTKFwiW3ZhdWwtZHJhd2VyXXt0b3VjaC1hY3Rpb246bm9uZTt3aWxsLWNoYW5nZTp0cmFuc2Zvcm07dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjVzIGN1YmljLWJlemllciguMzIsIC43MiwgMCwgMSl9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249Ym90dG9tXXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwxMDAlLDApfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPXRvcF17dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTEwMCUsMCl9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249bGVmdF17dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xMDAlLDAsMCl9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249cmlnaHRde3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgxMDAlLDAsMCl9LnZhdWwtZHJhZ2dpbmcgLnZhdWwtc2Nyb2xsYWJsZSBbdmF1bHQtZHJhd2VyLWRpcmVjdGlvbj10b3Bde292ZXJmbG93LXk6aGlkZGVuIWltcG9ydGFudH0udmF1bC1kcmFnZ2luZyAudmF1bC1zY3JvbGxhYmxlIFt2YXVsdC1kcmF3ZXItZGlyZWN0aW9uPWJvdHRvbV17b3ZlcmZsb3cteTpoaWRkZW4haW1wb3J0YW50fS52YXVsLWRyYWdnaW5nIC52YXVsLXNjcm9sbGFibGUgW3ZhdWx0LWRyYXdlci1kaXJlY3Rpb249bGVmdF17b3ZlcmZsb3cteDpoaWRkZW4haW1wb3J0YW50fS52YXVsLWRyYWdnaW5nIC52YXVsLXNjcm9sbGFibGUgW3ZhdWx0LWRyYXdlci1kaXJlY3Rpb249cmlnaHRde292ZXJmbG93LXg6aGlkZGVuIWltcG9ydGFudH1bdmF1bC1kcmF3ZXJdW3ZhdWwtZHJhd2VyLXZpc2libGU9dHJ1ZV1bdmF1bC1kcmF3ZXItZGlyZWN0aW9uPXRvcF17dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsdmFyKC0tc25hcC1wb2ludC1oZWlnaHQsMCksMCl9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci12aXNpYmxlPXRydWVdW3ZhdWwtZHJhd2VyLWRpcmVjdGlvbj1ib3R0b21de3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLHZhcigtLXNuYXAtcG9pbnQtaGVpZ2h0LDApLDApfVt2YXVsLWRyYXdlcl1bdmF1bC1kcmF3ZXItdmlzaWJsZT10cnVlXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249bGVmdF17dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKHZhcigtLXNuYXAtcG9pbnQtaGVpZ2h0LDApLDAsMCl9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci12aXNpYmxlPXRydWVdW3ZhdWwtZHJhd2VyLWRpcmVjdGlvbj1yaWdodF17dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKHZhcigtLXNuYXAtcG9pbnQtaGVpZ2h0LDApLDAsMCl9W3ZhdWwtb3ZlcmxheV17b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuNXMgY3ViaWMtYmV6aWVyKC4zMiwgLjcyLCAwLCAxKX1bdmF1bC1vdmVybGF5XVt2YXVsLWRyYXdlci12aXNpYmxlPXRydWVde29wYWNpdHk6MX1bdmF1bC1kcmF3ZXJdOjphZnRlcntjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQ6aW5oZXJpdDtiYWNrZ3JvdW5kLWNvbG9yOmluaGVyaXR9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249dG9wXTo6YWZ0ZXJ7dG9wOmluaXRpYWw7Ym90dG9tOjEwMCU7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjIwMCV9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249Ym90dG9tXTo6YWZ0ZXJ7dG9wOjEwMCU7Ym90dG9tOmluaXRpYWw7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjIwMCV9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249bGVmdF06OmFmdGVye2xlZnQ6aW5pdGlhbDtyaWdodDoxMDAlO3RvcDowO2JvdHRvbTowO3dpZHRoOjIwMCV9W3ZhdWwtZHJhd2VyXVt2YXVsLWRyYXdlci1kaXJlY3Rpb249cmlnaHRdOjphZnRlcntsZWZ0OjEwMCU7cmlnaHQ6aW5pdGlhbDt0b3A6MDtib3R0b206MDt3aWR0aDoyMDAlfVt2YXVsLWhhbmRsZV17ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtvcGFjaXR5Oi44O21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG87aGVpZ2h0OjVweDt3aWR0aDo1NnB4O2JvcmRlci1yYWRpdXM6MXJlbTt0b3VjaC1hY3Rpb246cGFuLXk7Y3Vyc29yOmdyYWJ9W3ZhdWwtaGFuZGxlXTphY3RpdmUsW3ZhdWwtaGFuZGxlXTpob3ZlcntvcGFjaXR5OjF9W3ZhdWwtaGFuZGxlXTphY3RpdmV7Y3Vyc29yOmdyYWJiaW5nfVt2YXVsLWhhbmRsZS1oaXRhcmVhXXtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwtNTAlKTt3aWR0aDptYXgoMTAwJSwyLjc1cmVtKTtoZWlnaHQ6bWF4KDEwMCUsMi43NXJlbSk7dG91Y2gtYWN0aW9uOmluaGVyaXR9W3ZhdWwtb3ZlcmxheV1bdmF1bC1zbmFwLXBvaW50cz10cnVlXTpub3QoW3ZhdWwtc25hcC1wb2ludHMtb3ZlcmxheT10cnVlXSk6bm90KFtkYXRhLXN0YXRlPWNsb3NlZF0pe29wYWNpdHk6MH1bdmF1bC1vdmVybGF5XVt2YXVsLXNuYXAtcG9pbnRzLW92ZXJsYXk9dHJ1ZV06bm90KFt2YXVsLWRyYXdlci12aXNpYmxlPWZhbHNlXSl7b3BhY2l0eToxfUBtZWRpYSAoaG92ZXI6aG92ZXIpIGFuZCAocG9pbnRlcjpmaW5lKXtbdmF1bC1kcmF3ZXJde3VzZXItc2VsZWN0Om5vbmV9fUBtZWRpYSAocG9pbnRlcjpmaW5lKXtbdmF1bC1oYW5kbGUtaGl0YXJlYV06e3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9fVwiKTtcblxuLy8gVGhpcyBjb2RlIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL2Jsb2IvbWFpbi9wYWNrYWdlcy8lNDByZWFjdC1hcmlhL292ZXJsYXlzL3NyYy91c2VQcmV2ZW50U2Nyb2xsLnRzXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5mdW5jdGlvbiBjaGFpbiguLi5jYWxsYmFja3MpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpPT57XG4gICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcyl7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gaXNNYWMoKSB7XG4gICAgcmV0dXJuIHRlc3RQbGF0Zm9ybSgvXk1hYy8pO1xufVxuZnVuY3Rpb24gaXNJUGhvbmUoKSB7XG4gICAgcmV0dXJuIHRlc3RQbGF0Zm9ybSgvXmlQaG9uZS8pO1xufVxuZnVuY3Rpb24gaXNJUGFkKCkge1xuICAgIHJldHVybiB0ZXN0UGxhdGZvcm0oL15pUGFkLykgfHwgLy8gaVBhZE9TIDEzIGxpZXMgYW5kIHNheXMgaXQncyBhIE1hYywgYnV0IHdlIGNhbiBkaXN0aW5ndWlzaCBieSBkZXRlY3RpbmcgdG91Y2ggc3VwcG9ydC5cbiAgICBpc01hYygpICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDE7XG59XG5mdW5jdGlvbiBpc0lPUygpIHtcbiAgICByZXR1cm4gaXNJUGhvbmUoKSB8fCBpc0lQYWQoKTtcbn1cbmZ1bmN0aW9uIHRlc3RQbGF0Zm9ybShyZSkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yICE9IG51bGwgPyByZS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pIDogdW5kZWZpbmVkO1xufVxuLy8gQHRzLWlnbm9yZVxuY29uc3QgdmlzdWFsVmlld3BvcnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbmZ1bmN0aW9uIGlzU2Nyb2xsYWJsZShub2RlKSB7XG4gICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgcmV0dXJuIC8oYXV0b3xzY3JvbGwpLy50ZXN0KHN0eWxlLm92ZXJmbG93ICsgc3R5bGUub3ZlcmZsb3dYICsgc3R5bGUub3ZlcmZsb3dZKTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gICAgaWYgKGlzU2Nyb2xsYWJsZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICB3aGlsZShub2RlICYmICFpc1Njcm9sbGFibGUobm9kZSkpe1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZSB8fCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cbi8vIEhUTUwgaW5wdXQgdHlwZXMgdGhhdCBkbyBub3QgY2F1c2UgdGhlIHNvZnR3YXJlIGtleWJvYXJkIHRvIGFwcGVhci5cbmNvbnN0IG5vblRleHRJbnB1dFR5cGVzID0gbmV3IFNldChbXG4gICAgJ2NoZWNrYm94JyxcbiAgICAncmFkaW8nLFxuICAgICdyYW5nZScsXG4gICAgJ2NvbG9yJyxcbiAgICAnZmlsZScsXG4gICAgJ2ltYWdlJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnc3VibWl0JyxcbiAgICAncmVzZXQnXG5dKTtcbi8vIFRoZSBudW1iZXIgb2YgYWN0aXZlIHVzZVByZXZlbnRTY3JvbGwgY2FsbHMuIFVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV2ZXJ0IGJhY2sgdG8gdGhlIG9yaWdpbmFsIHBhZ2Ugc3R5bGUvc2Nyb2xsIHBvc2l0aW9uXG5sZXQgcHJldmVudFNjcm9sbENvdW50ID0gMDtcbmxldCByZXN0b3JlO1xuLyoqXG4gKiBQcmV2ZW50cyBzY3JvbGxpbmcgb24gdGhlIGRvY3VtZW50IGJvZHkgb24gbW91bnQsIGFuZFxuICogcmVzdG9yZXMgaXQgb24gdW5tb3VudC4gQWxzbyBlbnN1cmVzIHRoYXQgY29udGVudCBkb2VzIG5vdFxuICogc2hpZnQgZHVlIHRvIHRoZSBzY3JvbGxiYXJzIGRpc2FwcGVhcmluZy5cbiAqLyBmdW5jdGlvbiB1c2VQcmV2ZW50U2Nyb2xsKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB7IGlzRGlzYWJsZWQgfSA9IG9wdGlvbnM7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByZXZlbnRTY3JvbGxDb3VudCsrO1xuICAgICAgICBpZiAocHJldmVudFNjcm9sbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNJT1MoKSkge1xuICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBwcmV2ZW50U2Nyb2xsTW9iaWxlU2FmYXJpKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBwcmV2ZW50U2Nyb2xsU3RhbmRhcmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHByZXZlbnRTY3JvbGxDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGlzRGlzYWJsZWRcbiAgICBdKTtcbn1cbi8vIEZvciBtb3N0IGJyb3dzZXJzLCBhbGwgd2UgbmVlZCB0byBkbyBpcyBzZXQgYG92ZXJmbG93OiBoaWRkZW5gIG9uIHRoZSByb290IGVsZW1lbnQsIGFuZFxuLy8gYWRkIHNvbWUgcGFkZGluZyB0byBwcmV2ZW50IHRoZSBwYWdlIGZyb20gc2hpZnRpbmcgd2hlbiB0aGUgc2Nyb2xsYmFyIGlzIGhpZGRlbi5cbmZ1bmN0aW9uIHByZXZlbnRTY3JvbGxTdGFuZGFyZCgpIHtcbiAgICByZXR1cm4gY2hhaW4oc2V0U3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAncGFkZGluZ1JpZ2h0JywgYCR7d2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh9cHhgKSk7XG59XG4vLyBNb2JpbGUgU2FmYXJpIGlzIGEgd2hvbGUgZGlmZmVyZW50IGJlYXN0LiBFdmVuIHdpdGggb3ZlcmZsb3c6IGhpZGRlbixcbi8vIGl0IHN0aWxsIHNjcm9sbHMgdGhlIHBhZ2UgaW4gbWFueSBzaXR1YXRpb25zOlxuLy9cbi8vIDEuIFdoZW4gdGhlIGJvdHRvbSB0b29sYmFyIGFuZCBhZGRyZXNzIGJhciBhcmUgY29sbGFwc2VkLCBwYWdlIHNjcm9sbGluZyBpcyBhbHdheXMgYWxsb3dlZC5cbi8vIDIuIFdoZW4gdGhlIGtleWJvYXJkIGlzIHZpc2libGUsIHRoZSB2aWV3cG9ydCBkb2VzIG5vdCByZXNpemUuIEluc3RlYWQsIHRoZSBrZXlib2FyZCBjb3ZlcnMgcGFydCBvZlxuLy8gICAgaXQsIHNvIGl0IGJlY29tZXMgc2Nyb2xsYWJsZS5cbi8vIDMuIFdoZW4gdGFwcGluZyBvbiBhbiBpbnB1dCwgdGhlIHBhZ2UgYWx3YXlzIHNjcm9sbHMgc28gdGhhdCB0aGUgaW5wdXQgaXMgY2VudGVyZWQgaW4gdGhlIHZpc3VhbCB2aWV3cG9ydC5cbi8vICAgIFRoaXMgbWF5IGNhdXNlIGV2ZW4gZml4ZWQgcG9zaXRpb24gZWxlbWVudHMgdG8gc2Nyb2xsIG9mZiB0aGUgc2NyZWVuLlxuLy8gNC4gV2hlbiB1c2luZyB0aGUgbmV4dC9wcmV2aW91cyBidXR0b25zIGluIHRoZSBrZXlib2FyZCB0byBuYXZpZ2F0ZSBiZXR3ZWVuIGlucHV0cywgdGhlIHdob2xlIHBhZ2UgYWx3YXlzXG4vLyAgICBzY3JvbGxzLCBldmVuIGlmIHRoZSBpbnB1dCBpcyBpbnNpZGUgYSBuZXN0ZWQgc2Nyb2xsYWJsZSBlbGVtZW50IHRoYXQgY291bGQgYmUgc2Nyb2xsZWQgaW5zdGVhZC5cbi8vXG4vLyBJbiBvcmRlciB0byB3b3JrIGFyb3VuZCB0aGVzZSBjYXNlcywgYW5kIHByZXZlbnQgc2Nyb2xsaW5nIHdpdGhvdXQgamFua2luZXNzLCB3ZSBkbyBhIGZldyB0aGluZ3M6XG4vL1xuLy8gMS4gUHJldmVudCBkZWZhdWx0IG9uIGB0b3VjaG1vdmVgIGV2ZW50cyB0aGF0IGFyZSBub3QgaW4gYSBzY3JvbGxhYmxlIGVsZW1lbnQuIFRoaXMgcHJldmVudHMgdG91Y2ggc2Nyb2xsaW5nXG4vLyAgICBvbiB0aGUgd2luZG93LlxuLy8gMi4gUHJldmVudCBkZWZhdWx0IG9uIGB0b3VjaG1vdmVgIGV2ZW50cyBpbnNpZGUgYSBzY3JvbGxhYmxlIGVsZW1lbnQgd2hlbiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIGF0IHRoZVxuLy8gICAgdG9wIG9yIGJvdHRvbS4gVGhpcyBhdm9pZHMgdGhlIHdob2xlIHBhZ2Ugc2Nyb2xsaW5nIGluc3RlYWQsIGJ1dCBkb2VzIHByZXZlbnQgb3ZlcnNjcm9sbGluZy5cbi8vIDMuIFByZXZlbnQgZGVmYXVsdCBvbiBgdG91Y2hlbmRgIGV2ZW50cyBvbiBpbnB1dCBlbGVtZW50cyBhbmQgaGFuZGxlIGZvY3VzaW5nIHRoZSBlbGVtZW50IG91cnNlbHZlcy5cbi8vIDQuIFdoZW4gZm9jdXNpbmcgYW4gaW5wdXQsIGFwcGx5IGEgdHJhbnNmb3JtIHRvIHRyaWNrIFNhZmFyaSBpbnRvIHRoaW5raW5nIHRoZSBpbnB1dCBpcyBhdCB0aGUgdG9wXG4vLyAgICBvZiB0aGUgcGFnZSwgd2hpY2ggcHJldmVudHMgaXQgZnJvbSBzY3JvbGxpbmcgdGhlIHBhZ2UuIEFmdGVyIHRoZSBpbnB1dCBpcyBmb2N1c2VkLCBzY3JvbGwgdGhlIGVsZW1lbnRcbi8vICAgIGludG8gdmlldyBvdXJzZWx2ZXMsIHdpdGhvdXQgc2Nyb2xsaW5nIHRoZSB3aG9sZSBwYWdlLlxuLy8gNS4gT2Zmc2V0IHRoZSBib2R5IGJ5IHRoZSBzY3JvbGwgcG9zaXRpb24gdXNpbmcgYSBuZWdhdGl2ZSBtYXJnaW4gYW5kIHNjcm9sbCB0byB0aGUgdG9wLiBUaGlzIHNob3VsZCBhcHBlYXIgdGhlXG4vLyAgICBzYW1lIHZpc3VhbGx5LCBidXQgbWFrZXMgdGhlIGFjdHVhbCBzY3JvbGwgcG9zaXRpb24gYWx3YXlzIHplcm8uIFRoaXMgaXMgcmVxdWlyZWQgdG8gbWFrZSBhbGwgb2YgdGhlXG4vLyAgICBhYm92ZSB3b3JrIG9yIFNhZmFyaSB3aWxsIHN0aWxsIHRyeSB0byBzY3JvbGwgdGhlIHBhZ2Ugd2hlbiBmb2N1c2luZyBhbiBpbnB1dC5cbi8vIDYuIEFzIGEgbGFzdCByZXNvcnQsIGhhbmRsZSB3aW5kb3cgc2Nyb2xsIGV2ZW50cywgYW5kIHNjcm9sbCBiYWNrIHRvIHRoZSB0b3AuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGF0dGVtcHRpbmdcbi8vICAgIHRvIG5hdmlnYXRlIHRvIGFuIGlucHV0IHdpdGggdGhlIG5leHQvcHJldmlvdXMgYnV0dG9ucyB0aGF0J3Mgb3V0c2lkZSBhIG1vZGFsLlxuZnVuY3Rpb24gcHJldmVudFNjcm9sbE1vYmlsZVNhZmFyaSgpIHtcbiAgICBsZXQgc2Nyb2xsYWJsZTtcbiAgICBsZXQgbGFzdFkgPSAwO1xuICAgIGxldCBvblRvdWNoU3RhcnQgPSAoZSk9PntcbiAgICAgICAgLy8gU3RvcmUgdGhlIG5lYXJlc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgZWxlbWVudCBmcm9tIHRoZSBlbGVtZW50IHRoYXQgdGhlIHVzZXIgdG91Y2hlZC5cbiAgICAgICAgc2Nyb2xsYWJsZSA9IGdldFNjcm9sbFBhcmVudChlLnRhcmdldCk7XG4gICAgICAgIGlmIChzY3JvbGxhYmxlID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgc2Nyb2xsYWJsZSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RZID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgICB9O1xuICAgIGxldCBvblRvdWNoTW92ZSA9IChlKT0+e1xuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyB0aGUgd2luZG93LlxuICAgICAgICBpZiAoIXNjcm9sbGFibGUgfHwgc2Nyb2xsYWJsZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IHNjcm9sbGFibGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyB1cCB3aGVuIGF0IHRoZSB0b3AgYW5kIHNjcm9sbGluZyBkb3duIHdoZW4gYXQgdGhlIGJvdHRvbVxuICAgICAgICAvLyBvZiBhIG5lc3RlZCBzY3JvbGxhYmxlIGFyZWEsIG90aGVyd2lzZSBtb2JpbGUgU2FmYXJpIHdpbGwgc3RhcnQgc2Nyb2xsaW5nXG4gICAgICAgIC8vIHRoZSB3aW5kb3cgaW5zdGVhZC4gVW5mb3J0dW5hdGVseSwgdGhpcyBkaXNhYmxlcyBib3VuY2Ugc2Nyb2xsaW5nIHdoZW4gYXRcbiAgICAgICAgLy8gdGhlIHRvcCBidXQgaXQncyB0aGUgYmVzdCB3ZSBjYW4gZG8uXG4gICAgICAgIGxldCB5ID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHNjcm9sbGFibGUuc2Nyb2xsVG9wO1xuICAgICAgICBsZXQgYm90dG9tID0gc2Nyb2xsYWJsZS5zY3JvbGxIZWlnaHQgLSBzY3JvbGxhYmxlLmNsaWVudEhlaWdodDtcbiAgICAgICAgaWYgKGJvdHRvbSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxUb3AgPD0gMCAmJiB5ID4gbGFzdFkgfHwgc2Nyb2xsVG9wID49IGJvdHRvbSAmJiB5IDwgbGFzdFkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0WSA9IHk7XG4gICAgfTtcbiAgICBsZXQgb25Ub3VjaEVuZCA9IChlKT0+e1xuICAgICAgICBsZXQgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIC8vIEFwcGx5IHRoaXMgY2hhbmdlIGlmIHdlJ3JlIG5vdCBhbHJlYWR5IGZvY3VzZWQgb24gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgIGlmIChpc0lucHV0KHRhcmdldCkgJiYgdGFyZ2V0ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBBcHBseSBhIHRyYW5zZm9ybSB0byB0cmljayBTYWZhcmkgaW50byB0aGlua2luZyB0aGUgaW5wdXQgaXMgYXQgdGhlIHRvcCBvZiB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gc28gaXQgZG9lc24ndCB0cnkgdG8gc2Nyb2xsIGl0IGludG8gdmlldy4gV2hlbiB0YXBwaW5nIG9uIGFuIGlucHV0LCB0aGlzIG5lZWRzIHRvXG4gICAgICAgICAgICAvLyBiZSBkb25lIGJlZm9yZSB0aGUgXCJmb2N1c1wiIGV2ZW50LCBzbyB3ZSBoYXZlIHRvIGZvY3VzIHRoZSBlbGVtZW50IG91cnNlbHZlcy5cbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgtMjAwMHB4KSc7XG4gICAgICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgb25Gb2N1cyA9IChlKT0+e1xuICAgICAgICBsZXQgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIGlmIChpc0lucHV0KHRhcmdldCkpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBhbHNvIG5lZWRzIHRvIGJlIGFwcGxpZWQgaW4gdGhlIGZvY3VzIGV2ZW50IGluIGNhc2VzIHdoZXJlIGZvY3VzIG1vdmVzXG4gICAgICAgICAgICAvLyBvdGhlciB0aGFuIHRhcHBpbmcgb24gYW4gaW5wdXQgZGlyZWN0bHksIGUuZy4gdGhlIG5leHQvcHJldmlvdXMgYnV0dG9ucyBpbiB0aGVcbiAgICAgICAgICAgIC8vIHNvZnR3YXJlIGtleWJvYXJkLiBJbiB0aGVzZSBjYXNlcywgaXQgc2VlbXMgYXBwbHlpbmcgdGhlIHRyYW5zZm9ybSBpbiB0aGUgZm9jdXMgZXZlbnRcbiAgICAgICAgICAgIC8vIGlzIGdvb2QgZW5vdWdoLCB3aGVyZWFzIHdoZW4gdGFwcGluZyBhbiBpbnB1dCwgaXQgbXVzdCBiZSBkb25lIGJlZm9yZSB0aGUgZm9jdXMgZXZlbnQuIPCfpLfigI3imYLvuI9cbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgtMjAwMHB4KSc7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGhhdmUgcHJldmVudGVkIHRoZSBicm93c2VyIGZyb20gc2Nyb2xsaW5nIHRoZSBmb2N1c2VkIGVsZW1lbnQgaW50byB2aWV3LFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZG8gdGhpcyBvdXJzZWx2ZXMgaW4gYSB3YXkgdGhhdCBkb2Vzbid0IGNhdXNlIHRoZSB3aG9sZSBwYWdlIHRvIHNjcm9sbC5cbiAgICAgICAgICAgICAgICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc3VhbFZpZXdwb3J0LmhlaWdodCA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGtleWJvYXJkIGlzIGFscmVhZHkgdmlzaWJsZSwgZG8gdGhpcyBhZnRlciBvbmUgYWRkaXRpb25hbCBmcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gd2FpdCBmb3IgdGhlIHRyYW5zZm9ybSB0byBiZSByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3YWl0IGZvciB0aGUgdmlzdWFsIHZpZXdwb3J0IHRvIHJlc2l6ZSBiZWZvcmUgc2Nyb2xsaW5nIHNvIHdlIGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVhc3VyZSB0aGUgY29ycmVjdCBwb3NpdGlvbiB0byBzY3JvbGwgdG8uXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKT0+c2Nyb2xsSW50b1ZpZXcodGFyZ2V0KSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBvbldpbmRvd1Njcm9sbCA9ICgpPT57XG4gICAgICAgIC8vIExhc3QgcmVzb3J0LiBJZiB0aGUgd2luZG93IHNjcm9sbGVkLCBzY3JvbGwgaXQgYmFjayB0byB0aGUgdG9wLlxuICAgICAgICAvLyBJdCBzaG91bGQgYWx3YXlzIGJlIGF0IHRoZSB0b3AgYmVjYXVzZSB0aGUgYm9keSB3aWxsIGhhdmUgYSBuZWdhdGl2ZSBtYXJnaW4gKHNlZSBiZWxvdykuXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9O1xuICAgIC8vIFJlY29yZCB0aGUgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uIHNvIHdlIGNhbiByZXN0b3JlIGl0LlxuICAgIC8vIFRoZW4gYXBwbHkgYSBuZWdhdGl2ZSBtYXJnaW4gdG8gdGhlIGJvZHkgdG8gb2Zmc2V0IGl0IGJ5IHRoZSBzY3JvbGwgcG9zaXRpb24uIFRoaXMgd2lsbFxuICAgIC8vIGVuYWJsZSB1cyB0byBzY3JvbGwgdGhlIHdpbmRvdyB0byB0aGUgdG9wLCB3aGljaCBpcyByZXF1aXJlZCBmb3IgdGhlIHJlc3Qgb2YgdGhpcyB0byB3b3JrLlxuICAgIGxldCBzY3JvbGxYID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgIGxldCBzY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIGxldCByZXN0b3JlU3R5bGVzID0gY2hhaW4oc2V0U3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAncGFkZGluZ1JpZ2h0JywgYCR7d2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh9cHhgKSk7XG4gICAgLy8gU2Nyb2xsIHRvIHRoZSB0b3AuIFRoZSBuZWdhdGl2ZSBtYXJnaW4gb24gdGhlIGJvZHkgd2lsbCBtYWtlIHRoaXMgYXBwZWFyIHRoZSBzYW1lLlxuICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICBsZXQgcmVtb3ZlRXZlbnRzID0gY2hhaW4oYWRkRXZlbnQoZG9jdW1lbnQsICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSksIGFkZEV2ZW50KGRvY3VtZW50LCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KSwgYWRkRXZlbnQoZG9jdW1lbnQsICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KSwgYWRkRXZlbnQoZG9jdW1lbnQsICdmb2N1cycsIG9uRm9jdXMsIHRydWUpLCBhZGRFdmVudCh3aW5kb3csICdzY3JvbGwnLCBvbldpbmRvd1Njcm9sbCkpO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICAvLyBSZXN0b3JlIHN0eWxlcyBhbmQgc2Nyb2xsIHRoZSBwYWdlIGJhY2sgdG8gd2hlcmUgaXQgd2FzLlxuICAgICAgICByZXN0b3JlU3R5bGVzKCk7XG4gICAgICAgIHJlbW92ZUV2ZW50cygpO1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oc2Nyb2xsWCwgc2Nyb2xsWSk7XG4gICAgfTtcbn1cbi8vIFNldHMgYSBDU1MgcHJvcGVydHkgb24gYW4gZWxlbWVudCwgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0byByZXZlcnQgaXQgdG8gdGhlIHByZXZpb3VzIHZhbHVlLlxuZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGUsIHZhbHVlKSB7XG4gICAgbGV0IGN1ciA9IGVsZW1lbnQuc3R5bGVbc3R5bGVdO1xuICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVdID0gdmFsdWU7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVdID0gY3VyO1xuICAgIH07XG59XG4vLyBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQsIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gcmVtb3ZlIGl0LlxuZnVuY3Rpb24gYWRkRXZlbnQodGFyZ2V0LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyh0YXJnZXQpIHtcbiAgICBsZXQgcm9vdCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHdoaWxlKHRhcmdldCAmJiB0YXJnZXQgIT09IHJvb3Qpe1xuICAgICAgICAvLyBGaW5kIHRoZSBwYXJlbnQgc2Nyb2xsYWJsZSBlbGVtZW50IGFuZCBhZGp1c3QgdGhlIHNjcm9sbCBwb3NpdGlvbiBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBhbHJlYWR5IGluIHZpZXcuXG4gICAgICAgIGxldCBzY3JvbGxhYmxlID0gZ2V0U2Nyb2xsUGFyZW50KHRhcmdldCk7XG4gICAgICAgIGlmIChzY3JvbGxhYmxlICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgc2Nyb2xsYWJsZSAhPT0gZG9jdW1lbnQuYm9keSAmJiBzY3JvbGxhYmxlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxhYmxlVG9wID0gc2Nyb2xsYWJsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgICAgIGxldCB0YXJnZXRCb3R0b20gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuICAgICAgICAgICAgY29uc3Qga2V5Ym9hcmRIZWlnaHQgPSBzY3JvbGxhYmxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRCb3R0b20gPiBrZXlib2FyZEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbGFibGUuc2Nyb2xsVG9wICs9IHRhcmdldFRvcCAtIHNjcm9sbGFibGVUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0YXJnZXQgPSBzY3JvbGxhYmxlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJbnB1dCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiAhbm9uVGV4dElucHV0VHlwZXMuaGFzKHRhcmdldC50eXBlKSB8fCB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcbn1cblxuLy8gVGhpcyBjb2RlIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3JhZGl4LXVpL3ByaW1pdGl2ZXMvdHJlZS9tYWluL3BhY2thZ2VzL3JlYWN0L2NvbXBvc2UtcmVmc1xuLyoqXG4gKiBTZXQgYSBnaXZlbiByZWYgdG8gYSBnaXZlbiB2YWx1ZVxuICogVGhpcyB1dGlsaXR5IHRha2VzIGNhcmUgb2YgZGlmZmVyZW50IHR5cGVzIG9mIHJlZnM6IGNhbGxiYWNrIHJlZnMgYW5kIFJlZk9iamVjdChzKVxuICovIGZ1bmN0aW9uIHNldFJlZihyZWYsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbn1cbi8qKlxuICogQSB1dGlsaXR5IHRvIGNvbXBvc2UgbXVsdGlwbGUgcmVmcyB0b2dldGhlclxuICogQWNjZXB0cyBjYWxsYmFjayByZWZzIGFuZCBSZWZPYmplY3QocylcbiAqLyBmdW5jdGlvbiBjb21wb3NlUmVmcyguLi5yZWZzKSB7XG4gICAgcmV0dXJuIChub2RlKT0+cmVmcy5mb3JFYWNoKChyZWYpPT5zZXRSZWYocmVmLCBub2RlKSk7XG59XG4vKipcbiAqIEEgY3VzdG9tIGhvb2sgdGhhdCBjb21wb3NlcyBtdWx0aXBsZSByZWZzXG4gKiBBY2NlcHRzIGNhbGxiYWNrIHJlZnMgYW5kIFJlZk9iamVjdChzKVxuICovIGZ1bmN0aW9uIHVzZUNvbXBvc2VkUmVmcyguLi5yZWZzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhjb21wb3NlUmVmcyguLi5yZWZzKSwgcmVmcyk7XG59XG5cbmxldCBwcmV2aW91c0JvZHlQb3NpdGlvbiA9IG51bGw7XG5mdW5jdGlvbiB1c2VQb3NpdGlvbkZpeGVkKHsgaXNPcGVuLCBtb2RhbCwgbmVzdGVkLCBoYXNCZWVuT3BlbmVkLCBwcmV2ZW50U2Nyb2xsUmVzdG9yYXRpb24sIG5vQm9keVN0eWxlcyB9KSB7XG4gICAgY29uc3QgW2FjdGl2ZVVybCwgc2V0QWN0aXZlVXJsXSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKCgpPT50eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogJycpO1xuICAgIGNvbnN0IHNjcm9sbFBvcyA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZigwKTtcbiAgICBjb25zdCBzZXRQb3NpdGlvbkZpeGVkID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgLy8gSWYgcHJldmlvdXNCb2R5UG9zaXRpb24gaXMgYWxyZWFkeSBzZXQsIGRvbid0IHNldCBpdCBhZ2Fpbi5cbiAgICAgICAgaWYgKHByZXZpb3VzQm9keVBvc2l0aW9uID09PSBudWxsICYmIGlzT3BlbiAmJiAhbm9Cb2R5U3R5bGVzKSB7XG4gICAgICAgICAgICBwcmV2aW91c0JvZHlQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZG9jdW1lbnQuYm9keS5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICB0b3A6IGRvY3VtZW50LmJvZHkuc3R5bGUudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGRvY3VtZW50LmJvZHkuc3R5bGUubGVmdCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGRvY3VtZW50LmJvZHkuc3R5bGUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAndW5zZXQnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBkb20gaW5zaWRlIGFuIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICAgICAgY29uc3QgeyBzY3JvbGxYLCBpbm5lckhlaWdodCB9ID0gd2luZG93O1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5zZXRQcm9wZXJ0eSgncG9zaXRpb24nLCAnZml4ZWQnLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRvY3VtZW50LmJvZHkuc3R5bGUsIHtcbiAgICAgICAgICAgICAgICB0b3A6IGAkey1zY3JvbGxQb3MuY3VycmVudH1weGAsXG4gICAgICAgICAgICAgICAgbGVmdDogYCR7LXNjcm9sbFh9cHhgLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAnMHB4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKT0+d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGNoZWNrIGlmIHRoZSBib3R0b20gYmFyIGFwcGVhcmVkIGR1ZSB0byB0aGUgcG9zaXRpb24gY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdHRvbUJhckhlaWdodCA9IGlubmVySGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tQmFySGVpZ2h0ICYmIHNjcm9sbFBvcy5jdXJyZW50ID49IGlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBjb250ZW50IGZ1cnRoZXIgdXAgc28gdGhhdCB0aGUgYm90dG9tIGJhciBkb2Vzbid0IGhpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUudG9wID0gYCR7LShzY3JvbGxQb3MuY3VycmVudCArIGJvdHRvbUJhckhlaWdodCl9cHhgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIDMwMCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzT3BlblxuICAgIF0pO1xuICAgIGNvbnN0IHJlc3RvcmVQb3NpdGlvblNldHRpbmcgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICBpZiAocHJldmlvdXNCb2R5UG9zaXRpb24gIT09IG51bGwgJiYgIW5vQm9keVN0eWxlcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcG9zaXRpb24gZnJvbSBcInB4XCIgdG8gSW50XG4gICAgICAgICAgICBjb25zdCB5ID0gLXBhcnNlSW50KGRvY3VtZW50LmJvZHkuc3R5bGUudG9wLCAxMCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gLXBhcnNlSW50KGRvY3VtZW50LmJvZHkuc3R5bGUubGVmdCwgMTApO1xuICAgICAgICAgICAgLy8gUmVzdG9yZSBzdHlsZXNcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuYm9keS5zdHlsZSwgcHJldmlvdXNCb2R5UG9zaXRpb24pO1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50U2Nyb2xsUmVzdG9yYXRpb24gJiYgYWN0aXZlVXJsICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVVcmwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJldmlvdXNCb2R5UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBhY3RpdmVVcmxcbiAgICBdKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gICAgICAgICAgICBzY3JvbGxQb3MuY3VycmVudCA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICB9XG4gICAgICAgIG9uU2Nyb2xsKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChuZXN0ZWQgfHwgIWhhc0JlZW5PcGVuZWQpIHJldHVybjtcbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gZm9yY2UgU2FmYXJpIHRvb2xiYXIgdG8gc2hvdyAqKmJlZm9yZSoqIHRoZSBkcmF3ZXIgc3RhcnRzIGFuaW1hdGluZyB0byBwcmV2ZW50IGEgZ25hcmx5IHNoaWZ0IGZyb20gaGFwcGVuaW5nXG4gICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgIC8vIGF2b2lkIGZvciBzdGFuZGFsb25lIG1vZGUgKFBXQSlcbiAgICAgICAgICAgIGNvbnN0IGlzU3RhbmRhbG9uZSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcoZGlzcGxheS1tb2RlOiBzdGFuZGFsb25lKScpLm1hdGNoZXM7XG4gICAgICAgICAgICAhaXNTdGFuZGFsb25lICYmIHNldFBvc2l0aW9uRml4ZWQoKTtcbiAgICAgICAgICAgIGlmICghbW9kYWwpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlUG9zaXRpb25TZXR0aW5nKCk7XG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3RvcmVQb3NpdGlvblNldHRpbmcoKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgaXNPcGVuLFxuICAgICAgICBoYXNCZWVuT3BlbmVkLFxuICAgICAgICBhY3RpdmVVcmwsXG4gICAgICAgIG1vZGFsLFxuICAgICAgICBuZXN0ZWQsXG4gICAgICAgIHNldFBvc2l0aW9uRml4ZWQsXG4gICAgICAgIHJlc3RvcmVQb3NpdGlvblNldHRpbmdcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0b3JlUG9zaXRpb25TZXR0aW5nXG4gICAgfTtcbn1cblxuY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0KGVsLCBzdHlsZXMsIGlnbm9yZUNhY2hlID0gZmFsc2UpIHtcbiAgICBpZiAoIWVsIHx8ICEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcbiAgICBsZXQgb3JpZ2luYWxTdHlsZXMgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyhzdHlsZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSk9PntcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCctLScpKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcmlnaW5hbFN0eWxlc1trZXldID0gZWwuc3R5bGVba2V5XTtcbiAgICAgICAgZWwuc3R5bGVba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIGlmIChpZ25vcmVDYWNoZSkgcmV0dXJuO1xuICAgIGNhY2hlLnNldChlbCwgb3JpZ2luYWxTdHlsZXMpO1xufVxuZnVuY3Rpb24gcmVzZXQoZWwsIHByb3ApIHtcbiAgICBpZiAoIWVsIHx8ICEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcbiAgICBsZXQgb3JpZ2luYWxTdHlsZXMgPSBjYWNoZS5nZXQoZWwpO1xuICAgIGlmICghb3JpZ2luYWxTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvcCkge1xuICAgICAgICBlbC5zdHlsZVtwcm9wXSA9IG9yaWdpbmFsU3R5bGVzW3Byb3BdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG9yaWdpbmFsU3R5bGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pPT57XG4gICAgICAgICAgICBlbC5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IGlzVmVydGljYWwgPSAoZGlyZWN0aW9uKT0+e1xuICAgIHN3aXRjaChkaXJlY3Rpb24pe1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRUcmFuc2xhdGUoZWxlbWVudCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IC8vIEB0cy1pZ25vcmVcbiAgICBzdHlsZS50cmFuc2Zvcm0gfHwgc3R5bGUud2Via2l0VHJhbnNmb3JtIHx8IHN0eWxlLm1velRyYW5zZm9ybTtcbiAgICBsZXQgbWF0ID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4M2RcXCgoLispXFwpJC8pO1xuICAgIGlmIChtYXQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybS1mdW5jdGlvbi9tYXRyaXgzZFxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRbMV0uc3BsaXQoJywgJylbaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gMTMgOiAxMl0pO1xuICAgIH1cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdHJhbnNmb3JtLWZ1bmN0aW9uL21hdHJpeFxuICAgIG1hdCA9IHRyYW5zZm9ybS5tYXRjaCgvXm1hdHJpeFxcKCguKylcXCkkLyk7XG4gICAgcmV0dXJuIG1hdCA/IHBhcnNlRmxvYXQobWF0WzFdLnNwbGl0KCcsICcpW2lzVmVydGljYWwoZGlyZWN0aW9uKSA/IDUgOiA0XSkgOiBudWxsO1xufVxuZnVuY3Rpb24gZGFtcGVuVmFsdWUodikge1xuICAgIHJldHVybiA4ICogKE1hdGgubG9nKHYgKyAxKSAtIDIpO1xufVxuXG5jb25zdCBUUkFOU0lUSU9OUyA9IHtcbiAgICBEVVJBVElPTjogMC41LFxuICAgIEVBU0U6IFtcbiAgICAgICAgMC4zMixcbiAgICAgICAgMC43MixcbiAgICAgICAgMCxcbiAgICAgICAgMVxuICAgIF1cbn07XG5jb25zdCBWRUxPQ0lUWV9USFJFU0hPTEQgPSAwLjQ7XG5cbi8vIFRoaXMgY29kZSBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWRpeC11aS9wcmltaXRpdmVzL2Jsb2IvbWFpbi9wYWNrYWdlcy9yZWFjdC91c2UtY29udHJvbGxhYmxlLXN0YXRlL3NyYy91c2VDb250cm9sbGFibGVTdGF0ZS50c3hcbmZ1bmN0aW9uIHVzZUNhbGxiYWNrUmVmKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2FsbGJhY2tSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoY2FsbGJhY2spO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBjYWxsYmFja1JlZi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gICAgfSk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTI0MFxuICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC51c2VNZW1vKCgpPT4oLi4uYXJncyk9PmNhbGxiYWNrUmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrUmVmLmN1cnJlbnQuY2FsbChjYWxsYmFja1JlZiwgLi4uYXJncyksIFtdKTtcbn1cbmZ1bmN0aW9uIHVzZVVuY29udHJvbGxlZFN0YXRlKHsgZGVmYXVsdFByb3AsIG9uQ2hhbmdlIH0pIHtcbiAgICBjb25zdCB1bmNvbnRyb2xsZWRTdGF0ZSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGRlZmF1bHRQcm9wKTtcbiAgICBjb25zdCBbdmFsdWVdID0gdW5jb250cm9sbGVkU3RhdGU7XG4gICAgY29uc3QgcHJldlZhbHVlUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKHZhbHVlKTtcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFja1JlZihvbkNoYW5nZSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChwcmV2VmFsdWVSZWYuY3VycmVudCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGhhbmRsZUNoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgICBwcmV2VmFsdWVSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcHJldlZhbHVlUmVmLFxuICAgICAgICBoYW5kbGVDaGFuZ2VcbiAgICBdKTtcbiAgICByZXR1cm4gdW5jb250cm9sbGVkU3RhdGU7XG59XG5mdW5jdGlvbiB1c2VDb250cm9sbGFibGVTdGF0ZSh7IHByb3AsIGRlZmF1bHRQcm9wLCBvbkNoYW5nZSA9ICgpPT57fSB9KSB7XG4gICAgY29uc3QgW3VuY29udHJvbGxlZFByb3AsIHNldFVuY29udHJvbGxlZFByb3BdID0gdXNlVW5jb250cm9sbGVkU3RhdGUoe1xuICAgICAgICBkZWZhdWx0UHJvcCxcbiAgICAgICAgb25DaGFuZ2VcbiAgICB9KTtcbiAgICBjb25zdCBpc0NvbnRyb2xsZWQgPSBwcm9wICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgdmFsdWUgPSBpc0NvbnRyb2xsZWQgPyBwcm9wIDogdW5jb250cm9sbGVkUHJvcDtcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFja1JlZihvbkNoYW5nZSk7XG4gICAgY29uc3Qgc2V0VmFsdWUgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjaygobmV4dFZhbHVlKT0+e1xuICAgICAgICBpZiAoaXNDb250cm9sbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0ZXIgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBuZXh0VmFsdWUgPT09ICdmdW5jdGlvbicgPyBzZXR0ZXIocHJvcCkgOiBuZXh0VmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHByb3ApIGhhbmRsZUNoYW5nZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRVbmNvbnRyb2xsZWRQcm9wKG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzQ29udHJvbGxlZCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgc2V0VW5jb250cm9sbGVkUHJvcCxcbiAgICAgICAgaGFuZGxlQ2hhbmdlXG4gICAgXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHNldFZhbHVlXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gdXNlU25hcFBvaW50cyh7IGFjdGl2ZVNuYXBQb2ludFByb3AsIHNldEFjdGl2ZVNuYXBQb2ludFByb3AsIHNuYXBQb2ludHMsIGRyYXdlclJlZiwgb3ZlcmxheVJlZiwgZmFkZUZyb21JbmRleCwgb25TbmFwUG9pbnRDaGFuZ2UsIGRpcmVjdGlvbiA9ICdib3R0b20nIH0pIHtcbiAgICBjb25zdCBbYWN0aXZlU25hcFBvaW50LCBzZXRBY3RpdmVTbmFwUG9pbnRdID0gdXNlQ29udHJvbGxhYmxlU3RhdGUoe1xuICAgICAgICBwcm9wOiBhY3RpdmVTbmFwUG9pbnRQcm9wLFxuICAgICAgICBkZWZhdWx0UHJvcDogc25hcFBvaW50cyA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50c1swXSxcbiAgICAgICAgb25DaGFuZ2U6IHNldEFjdGl2ZVNuYXBQb2ludFByb3BcbiAgICB9KTtcbiAgICBjb25zdCBpc0xhc3RTbmFwUG9pbnQgPSBSZWFjdF9fZGVmYXVsdC51c2VNZW1vKCgpPT5hY3RpdmVTbmFwUG9pbnQgPT09IChzbmFwUG9pbnRzID09IG51bGwgPyB2b2lkIDAgOiBzbmFwUG9pbnRzW3NuYXBQb2ludHMubGVuZ3RoIC0gMV0pIHx8IG51bGwsIFtcbiAgICAgICAgc25hcFBvaW50cyxcbiAgICAgICAgYWN0aXZlU25hcFBvaW50XG4gICAgXSk7XG4gICAgY29uc3Qgc2hvdWxkRmFkZSA9IHNuYXBQb2ludHMgJiYgc25hcFBvaW50cy5sZW5ndGggPiAwICYmIChmYWRlRnJvbUluZGV4IHx8IGZhZGVGcm9tSW5kZXggPT09IDApICYmICFOdW1iZXIuaXNOYU4oZmFkZUZyb21JbmRleCkgJiYgc25hcFBvaW50c1tmYWRlRnJvbUluZGV4XSA9PT0gYWN0aXZlU25hcFBvaW50IHx8ICFzbmFwUG9pbnRzO1xuICAgIGNvbnN0IGFjdGl2ZVNuYXBQb2ludEluZGV4ID0gUmVhY3RfX2RlZmF1bHQudXNlTWVtbygoKT0+c25hcFBvaW50cyA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50cy5maW5kSW5kZXgoKHNuYXBQb2ludCk9PnNuYXBQb2ludCA9PT0gYWN0aXZlU25hcFBvaW50KSwgW1xuICAgICAgICBzbmFwUG9pbnRzLFxuICAgICAgICBhY3RpdmVTbmFwUG9pbnRcbiAgICBdKTtcbiAgICBjb25zdCBzbmFwUG9pbnRzT2Zmc2V0ID0gUmVhY3RfX2RlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICB2YXIgX3NuYXBQb2ludHNfbWFwO1xuICAgICAgICByZXR1cm4gKF9zbmFwUG9pbnRzX21hcCA9IHNuYXBQb2ludHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBQb2ludHMubWFwKChzbmFwUG9pbnQpPT57XG4gICAgICAgICAgICBjb25zdCBoYXNXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGNvbnN0IGlzUHggPSB0eXBlb2Ygc25hcFBvaW50ID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgIGxldCBzbmFwUG9pbnRBc051bWJlciA9IDA7XG4gICAgICAgICAgICBpZiAoaXNQeCkge1xuICAgICAgICAgICAgICAgIHNuYXBQb2ludEFzTnVtYmVyID0gcGFyc2VJbnQoc25hcFBvaW50LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWZXJ0aWNhbChkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaXNQeCA/IHNuYXBQb2ludEFzTnVtYmVyIDogaGFzV2luZG93ID8gc25hcFBvaW50ICogd2luZG93LmlubmVySGVpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gd2luZG93LmlubmVySGVpZ2h0IC0gaGVpZ2h0IDogLXdpbmRvdy5pbm5lckhlaWdodCArIGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaXNQeCA/IHNuYXBQb2ludEFzTnVtYmVyIDogaGFzV2luZG93ID8gc25hcFBvaW50ICogd2luZG93LmlubmVyV2lkdGggOiAwO1xuICAgICAgICAgICAgaWYgKGhhc1dpbmRvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyB3aW5kb3cuaW5uZXJXaWR0aCAtIHdpZHRoIDogLXdpbmRvdy5pbm5lcldpZHRoICsgd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH0pKSAhPSBudWxsID8gX3NuYXBQb2ludHNfbWFwIDogW107XG4gICAgfSwgW1xuICAgICAgICBzbmFwUG9pbnRzXG4gICAgXSk7XG4gICAgY29uc3QgYWN0aXZlU25hcFBvaW50T2Zmc2V0ID0gUmVhY3RfX2RlZmF1bHQudXNlTWVtbygoKT0+YWN0aXZlU25hcFBvaW50SW5kZXggIT09IG51bGwgPyBzbmFwUG9pbnRzT2Zmc2V0ID09IG51bGwgPyB2b2lkIDAgOiBzbmFwUG9pbnRzT2Zmc2V0W2FjdGl2ZVNuYXBQb2ludEluZGV4XSA6IG51bGwsIFtcbiAgICAgICAgc25hcFBvaW50c09mZnNldCxcbiAgICAgICAgYWN0aXZlU25hcFBvaW50SW5kZXhcbiAgICBdKTtcbiAgICBjb25zdCBzbmFwVG9Qb2ludCA9IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKChkaW1lbnNpb24pPT57XG4gICAgICAgIHZhciBfc25hcFBvaW50c09mZnNldF9maW5kSW5kZXg7XG4gICAgICAgIGNvbnN0IG5ld1NuYXBQb2ludEluZGV4ID0gKF9zbmFwUG9pbnRzT2Zmc2V0X2ZpbmRJbmRleCA9IHNuYXBQb2ludHNPZmZzZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBQb2ludHNPZmZzZXQuZmluZEluZGV4KChzbmFwUG9pbnREaW0pPT5zbmFwUG9pbnREaW0gPT09IGRpbWVuc2lvbikpICE9IG51bGwgPyBfc25hcFBvaW50c09mZnNldF9maW5kSW5kZXggOiBudWxsO1xuICAgICAgICBvblNuYXBQb2ludENoYW5nZShuZXdTbmFwUG9pbnRJbmRleCk7XG4gICAgICAgIHNldChkcmF3ZXJSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogYHRyYW5zZm9ybSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWAsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGB0cmFuc2xhdGUzZCgwLCAke2RpbWVuc2lvbn1weCwgMClgIDogYHRyYW5zbGF0ZTNkKCR7ZGltZW5zaW9ufXB4LCAwLCAwKWBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzbmFwUG9pbnRzT2Zmc2V0ICYmIG5ld1NuYXBQb2ludEluZGV4ICE9PSBzbmFwUG9pbnRzT2Zmc2V0Lmxlbmd0aCAtIDEgJiYgbmV3U25hcFBvaW50SW5kZXggIT09IGZhZGVGcm9tSW5kZXgpIHtcbiAgICAgICAgICAgIHNldChvdmVybGF5UmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWAsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogJzAnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldChvdmVybGF5UmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWAsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogJzEnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRBY3RpdmVTbmFwUG9pbnQobmV3U25hcFBvaW50SW5kZXggIT09IG51bGwgPyBzbmFwUG9pbnRzID09IG51bGwgPyB2b2lkIDAgOiBzbmFwUG9pbnRzW25ld1NuYXBQb2ludEluZGV4XSA6IG51bGwpO1xuICAgIH0sIFtcbiAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQsXG4gICAgICAgIHNuYXBQb2ludHMsXG4gICAgICAgIHNuYXBQb2ludHNPZmZzZXQsXG4gICAgICAgIGZhZGVGcm9tSW5kZXgsXG4gICAgICAgIG92ZXJsYXlSZWYsXG4gICAgICAgIHNldEFjdGl2ZVNuYXBQb2ludFxuICAgIF0pO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoYWN0aXZlU25hcFBvaW50IHx8IGFjdGl2ZVNuYXBQb2ludFByb3ApIHtcbiAgICAgICAgICAgIHZhciBfc25hcFBvaW50c19maW5kSW5kZXg7XG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IChfc25hcFBvaW50c19maW5kSW5kZXggPSBzbmFwUG9pbnRzID09IG51bGwgPyB2b2lkIDAgOiBzbmFwUG9pbnRzLmZpbmRJbmRleCgoc25hcFBvaW50KT0+c25hcFBvaW50ID09PSBhY3RpdmVTbmFwUG9pbnRQcm9wIHx8IHNuYXBQb2ludCA9PT0gYWN0aXZlU25hcFBvaW50KSkgIT0gbnVsbCA/IF9zbmFwUG9pbnRzX2ZpbmRJbmRleCA6IC0xO1xuICAgICAgICAgICAgaWYgKHNuYXBQb2ludHNPZmZzZXQgJiYgbmV3SW5kZXggIT09IC0xICYmIHR5cGVvZiBzbmFwUG9pbnRzT2Zmc2V0W25ld0luZGV4XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzbmFwVG9Qb2ludChzbmFwUG9pbnRzT2Zmc2V0W25ld0luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFjdGl2ZVNuYXBQb2ludCxcbiAgICAgICAgYWN0aXZlU25hcFBvaW50UHJvcCxcbiAgICAgICAgc25hcFBvaW50cyxcbiAgICAgICAgc25hcFBvaW50c09mZnNldCxcbiAgICAgICAgc25hcFRvUG9pbnRcbiAgICBdKTtcbiAgICBmdW5jdGlvbiBvblJlbGVhc2UoeyBkcmFnZ2VkRGlzdGFuY2UsIGNsb3NlRHJhd2VyLCB2ZWxvY2l0eSwgZGlzbWlzc2libGUgfSkge1xuICAgICAgICBpZiAoZmFkZUZyb21JbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvbiA9IGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnID8gKGFjdGl2ZVNuYXBQb2ludE9mZnNldCAhPSBudWxsID8gYWN0aXZlU25hcFBvaW50T2Zmc2V0IDogMCkgLSBkcmFnZ2VkRGlzdGFuY2UgOiAoYWN0aXZlU25hcFBvaW50T2Zmc2V0ICE9IG51bGwgPyBhY3RpdmVTbmFwUG9pbnRPZmZzZXQgOiAwKSArIGRyYWdnZWREaXN0YW5jZTtcbiAgICAgICAgY29uc3QgaXNPdmVybGF5U25hcFBvaW50ID0gYWN0aXZlU25hcFBvaW50SW5kZXggPT09IGZhZGVGcm9tSW5kZXggLSAxO1xuICAgICAgICBjb25zdCBpc0ZpcnN0ID0gYWN0aXZlU25hcFBvaW50SW5kZXggPT09IDA7XG4gICAgICAgIGNvbnN0IGhhc0RyYWdnZWRVcCA9IGRyYWdnZWREaXN0YW5jZSA+IDA7XG4gICAgICAgIGlmIChpc092ZXJsYXlTbmFwUG9pbnQpIHtcbiAgICAgICAgICAgIHNldChvdmVybGF5UmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZWxvY2l0eSA+IDIgJiYgIWhhc0RyYWdnZWRVcCkge1xuICAgICAgICAgICAgaWYgKGRpc21pc3NpYmxlKSBjbG9zZURyYXdlcigpO1xuICAgICAgICAgICAgZWxzZSBzbmFwVG9Qb2ludChzbmFwUG9pbnRzT2Zmc2V0WzBdKTsgLy8gc25hcCB0byBpbml0aWFsIHBvaW50XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlbG9jaXR5ID4gMiAmJiBoYXNEcmFnZ2VkVXAgJiYgc25hcFBvaW50c09mZnNldCAmJiBzbmFwUG9pbnRzKSB7XG4gICAgICAgICAgICBzbmFwVG9Qb2ludChzbmFwUG9pbnRzT2Zmc2V0W3NuYXBQb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgc25hcCBwb2ludCB0byB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICBjb25zdCBjbG9zZXN0U25hcFBvaW50ID0gc25hcFBvaW50c09mZnNldCA9PSBudWxsID8gdm9pZCAwIDogc25hcFBvaW50c09mZnNldC5yZWR1Y2UoKHByZXYsIGN1cnIpPT57XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZXYgIT09ICdudW1iZXInIHx8IHR5cGVvZiBjdXJyICE9PSAnbnVtYmVyJykgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoY3VyciAtIGN1cnJlbnRQb3NpdGlvbikgPCBNYXRoLmFicyhwcmV2IC0gY3VycmVudFBvc2l0aW9uKSA/IGN1cnIgOiBwcmV2O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGltID0gaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gd2luZG93LmlubmVySGVpZ2h0IDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGlmICh2ZWxvY2l0eSA+IFZFTE9DSVRZX1RIUkVTSE9MRCAmJiBNYXRoLmFicyhkcmFnZ2VkRGlzdGFuY2UpIDwgZGltICogMC40KSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnRGlyZWN0aW9uID0gaGFzRHJhZ2dlZFVwID8gMSA6IC0xOyAvLyAxID0gdXAsIC0xID0gZG93blxuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpcGUgdXB3YXJkcyB3aGlsZSBiZWluZyBvbiB0aGUgbGFzdCBzbmFwIHBvaW50XG4gICAgICAgICAgICBpZiAoZHJhZ0RpcmVjdGlvbiA+IDAgJiYgaXNMYXN0U25hcFBvaW50KSB7XG4gICAgICAgICAgICAgICAgc25hcFRvUG9pbnQoc25hcFBvaW50c09mZnNldFtzbmFwUG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGaXJzdCAmJiBkcmFnRGlyZWN0aW9uIDwgMCAmJiBkaXNtaXNzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNsb3NlRHJhd2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aXZlU25hcFBvaW50SW5kZXggPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIHNuYXBUb1BvaW50KHNuYXBQb2ludHNPZmZzZXRbYWN0aXZlU25hcFBvaW50SW5kZXggKyBkcmFnRGlyZWN0aW9uXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc25hcFRvUG9pbnQoY2xvc2VzdFNuYXBQb2ludCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRHJhZyh7IGRyYWdnZWREaXN0YW5jZSB9KSB7XG4gICAgICAgIGlmIChhY3RpdmVTbmFwUG9pbnRPZmZzZXQgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBkaXJlY3Rpb24gPT09ICdib3R0b20nIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IGFjdGl2ZVNuYXBQb2ludE9mZnNldCAtIGRyYWdnZWREaXN0YW5jZSA6IGFjdGl2ZVNuYXBQb2ludE9mZnNldCArIGRyYWdnZWREaXN0YW5jZTtcbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgd2UgZXhjZWVkIHRoZSBsYXN0KGJpZ2dlc3QpIHNuYXAgcG9pbnRcbiAgICAgICAgaWYgKChkaXJlY3Rpb24gPT09ICdib3R0b20nIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JykgJiYgbmV3VmFsdWUgPCBzbmFwUG9pbnRzT2Zmc2V0W3NuYXBQb2ludHNPZmZzZXQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGRpcmVjdGlvbiA9PT0gJ3RvcCcgfHwgZGlyZWN0aW9uID09PSAnbGVmdCcpICYmIG5ld1ZhbHVlID4gc25hcFBvaW50c09mZnNldFtzbmFwUG9pbnRzT2Zmc2V0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGB0cmFuc2xhdGUzZCgwLCAke25ld1ZhbHVlfXB4LCAwKWAgOiBgdHJhbnNsYXRlM2QoJHtuZXdWYWx1ZX1weCwgMCwgMClgXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQZXJjZW50YWdlRHJhZ2dlZChhYnNEcmFnZ2VkRGlzdGFuY2UsIGlzRHJhZ2dpbmdEb3duKSB7XG4gICAgICAgIGlmICghc25hcFBvaW50cyB8fCB0eXBlb2YgYWN0aXZlU25hcFBvaW50SW5kZXggIT09ICdudW1iZXInIHx8ICFzbmFwUG9pbnRzT2Zmc2V0IHx8IGZhZGVGcm9tSW5kZXggPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdHJ1ZSB3ZSBhcmUgZHJhZ2dpbmcgdG8gYSBzbmFwIHBvaW50IHRoYXQgaXMgc3VwcG9zZWQgdG8gaGF2ZSBhbiBvdmVybGF5XG4gICAgICAgIGNvbnN0IGlzT3ZlcmxheVNuYXBQb2ludCA9IGFjdGl2ZVNuYXBQb2ludEluZGV4ID09PSBmYWRlRnJvbUluZGV4IC0gMTtcbiAgICAgICAgY29uc3QgaXNPdmVybGF5U25hcFBvaW50T3JIaWdoZXIgPSBhY3RpdmVTbmFwUG9pbnRJbmRleCA+PSBmYWRlRnJvbUluZGV4O1xuICAgICAgICBpZiAoaXNPdmVybGF5U25hcFBvaW50T3JIaWdoZXIgJiYgaXNEcmFnZ2luZ0Rvd24pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGFuaW1hdGUsIGJ1dCBzdGlsbCB1c2UgdGhpcyBvbmUgaWYgd2UgYXJlIGRyYWdnaW5nIGF3YXkgZnJvbSB0aGUgb3ZlcmxheVNuYXBQb2ludFxuICAgICAgICBpZiAoaXNPdmVybGF5U25hcFBvaW50ICYmICFpc0RyYWdnaW5nRG93bikgcmV0dXJuIDE7XG4gICAgICAgIGlmICghc2hvdWxkRmFkZSAmJiAhaXNPdmVybGF5U25hcFBvaW50KSByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRWl0aGVyIGZhZGVGcm9tIGluZGV4IG9yIHRoZSBvbmUgYmVmb3JlXG4gICAgICAgIGNvbnN0IHRhcmdldFNuYXBQb2ludEluZGV4ID0gaXNPdmVybGF5U25hcFBvaW50ID8gYWN0aXZlU25hcFBvaW50SW5kZXggKyAxIDogYWN0aXZlU25hcFBvaW50SW5kZXggLSAxO1xuICAgICAgICAvLyBHZXQgdGhlIGRpc3RhbmNlIGZyb20gb3ZlcmxheVNuYXBQb2ludCB0byB0aGUgb25lIGJlZm9yZSBvciB2aWNlLXZlcnNhIHRvIGNhbGN1bGF0ZSB0aGUgb3BhY2l0eSBwZXJjZW50YWdlIGFjY29yZGluZ2x5XG4gICAgICAgIGNvbnN0IHNuYXBQb2ludERpc3RhbmNlID0gaXNPdmVybGF5U25hcFBvaW50ID8gc25hcFBvaW50c09mZnNldFt0YXJnZXRTbmFwUG9pbnRJbmRleF0gLSBzbmFwUG9pbnRzT2Zmc2V0W3RhcmdldFNuYXBQb2ludEluZGV4IC0gMV0gOiBzbmFwUG9pbnRzT2Zmc2V0W3RhcmdldFNuYXBQb2ludEluZGV4ICsgMV0gLSBzbmFwUG9pbnRzT2Zmc2V0W3RhcmdldFNuYXBQb2ludEluZGV4XTtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZURyYWdnZWQgPSBhYnNEcmFnZ2VkRGlzdGFuY2UgLyBNYXRoLmFicyhzbmFwUG9pbnREaXN0YW5jZSk7XG4gICAgICAgIGlmIChpc092ZXJsYXlTbmFwUG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gcGVyY2VudGFnZURyYWdnZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGVyY2VudGFnZURyYWdnZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNMYXN0U25hcFBvaW50LFxuICAgICAgICBhY3RpdmVTbmFwUG9pbnQsXG4gICAgICAgIHNob3VsZEZhZGUsXG4gICAgICAgIGdldFBlcmNlbnRhZ2VEcmFnZ2VkLFxuICAgICAgICBzZXRBY3RpdmVTbmFwUG9pbnQsXG4gICAgICAgIGFjdGl2ZVNuYXBQb2ludEluZGV4LFxuICAgICAgICBvblJlbGVhc2UsXG4gICAgICAgIG9uRHJhZyxcbiAgICAgICAgc25hcFBvaW50c09mZnNldFxuICAgIH07XG59XG5cbmNvbnN0IENMT1NFX1RIUkVTSE9MRCA9IDAuMjU7XG5jb25zdCBTQ1JPTExfTE9DS19USU1FT1VUID0gMTAwO1xuY29uc3QgQk9SREVSX1JBRElVUyA9IDg7XG5jb25zdCBORVNURURfRElTUExBQ0VNRU5UID0gMTY7XG5jb25zdCBXSU5ET1dfVE9QX09GRlNFVCA9IDI2O1xuY29uc3QgRFJBR19DTEFTUyA9ICd2YXVsLWRyYWdnaW5nJztcbmZ1bmN0aW9uIFJvb3QoeyBvcGVuOiBvcGVuUHJvcCwgb25PcGVuQ2hhbmdlLCBjaGlsZHJlbiwgc2hvdWxkU2NhbGVCYWNrZ3JvdW5kLCBvbkRyYWc6IG9uRHJhZ1Byb3AsIG9uUmVsZWFzZTogb25SZWxlYXNlUHJvcCwgc25hcFBvaW50cywgbmVzdGVkID0gZmFsc2UsIHNldEJhY2tncm91bmRDb2xvck9uU2NhbGUgPSB0cnVlLCBjbG9zZVRocmVzaG9sZCA9IENMT1NFX1RIUkVTSE9MRCwgc2Nyb2xsTG9ja1RpbWVvdXQgPSBTQ1JPTExfTE9DS19USU1FT1VULCBkaXNtaXNzaWJsZSA9IHRydWUsIGhhbmRsZU9ubHkgPSBmYWxzZSwgZmFkZUZyb21JbmRleCA9IHNuYXBQb2ludHMgJiYgc25hcFBvaW50cy5sZW5ndGggLSAxLCBhY3RpdmVTbmFwUG9pbnQ6IGFjdGl2ZVNuYXBQb2ludFByb3AsIHNldEFjdGl2ZVNuYXBQb2ludDogc2V0QWN0aXZlU25hcFBvaW50UHJvcCwgZml4ZWQsIG1vZGFsID0gdHJ1ZSwgb25DbG9zZSwgbm9Cb2R5U3R5bGVzLCBkaXJlY3Rpb24gPSAnYm90dG9tJywgcHJldmVudFNjcm9sbFJlc3RvcmF0aW9uID0gdHJ1ZSwgZGlzYWJsZVByZXZlbnRTY3JvbGwgPSBmYWxzZSB9KSB7XG4gICAgdmFyIF9kcmF3ZXJSZWZfY3VycmVudDtcbiAgICBjb25zdCBbaXNPcGVuID0gZmFsc2UsIHNldElzT3Blbl0gPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2hhc0JlZW5PcGVuZWQsIHNldEhhc0JlZW5PcGVuZWRdID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIE5vdCB2aXNpYmxlID0gdHJhbnNsYXRlWSgxMDAlKVxuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2lzRHJhZ2dpbmcsIHNldElzRHJhZ2dpbmddID0gUmVhY3RfX2RlZmF1bHQudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtqdXN0UmVsZWFzZWQsIHNldEp1c3RSZWxlYXNlZF0gPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3Qgb3ZlcmxheVJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBvcGVuVGltZSA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBkcmFnU3RhcnRUaW1lID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGRyYWdFbmRUaW1lID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGxhc3RUaW1lRHJhZ1ByZXZlbnRlZCA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpc0FsbG93ZWRUb0RyYWcgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IG5lc3RlZE9wZW5DaGFuZ2VUaW1lciA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBwb2ludGVyU3RhcnQgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoMCk7XG4gICAgY29uc3Qga2V5Ym9hcmRJc09wZW4gPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IHByZXZpb3VzRGlmZkZyb21Jbml0aWFsID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKDApO1xuICAgIGNvbnN0IGRyYXdlclJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBkcmF3ZXJIZWlnaHRSZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoKChfZHJhd2VyUmVmX2N1cnJlbnQgPSBkcmF3ZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kcmF3ZXJSZWZfY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpIHx8IDApO1xuICAgIGNvbnN0IGluaXRpYWxEcmF3ZXJIZWlnaHQgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoMCk7XG4gICAgY29uc3Qgb25TbmFwUG9pbnRDaGFuZ2UgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjaygoYWN0aXZlU25hcFBvaW50SW5kZXgpPT57XG4gICAgICAgIC8vIENoYW5nZSBvcGVuVGltZSByZWYgd2hlbiB3ZSByZWFjaCB0aGUgbGFzdCBzbmFwIHBvaW50IHRvIHByZXZlbnQgZHJhZ2dpbmcgZm9yIDUwMG1zIGluY2FzZSBpdCdzIHNjcm9sbGFibGUuXG4gICAgICAgIGlmIChzbmFwUG9pbnRzICYmIGFjdGl2ZVNuYXBQb2ludEluZGV4ID09PSBzbmFwUG9pbnRzT2Zmc2V0Lmxlbmd0aCAtIDEpIG9wZW5UaW1lLmN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCB7IGFjdGl2ZVNuYXBQb2ludCwgYWN0aXZlU25hcFBvaW50SW5kZXgsIHNldEFjdGl2ZVNuYXBQb2ludCwgb25SZWxlYXNlOiBvblJlbGVhc2VTbmFwUG9pbnRzLCBzbmFwUG9pbnRzT2Zmc2V0LCBvbkRyYWc6IG9uRHJhZ1NuYXBQb2ludHMsIHNob3VsZEZhZGUsIGdldFBlcmNlbnRhZ2VEcmFnZ2VkOiBnZXRTbmFwUG9pbnRzUGVyY2VudGFnZURyYWdnZWQgfSA9IHVzZVNuYXBQb2ludHMoe1xuICAgICAgICBzbmFwUG9pbnRzLFxuICAgICAgICBhY3RpdmVTbmFwUG9pbnRQcm9wLFxuICAgICAgICBzZXRBY3RpdmVTbmFwUG9pbnRQcm9wLFxuICAgICAgICBkcmF3ZXJSZWYsXG4gICAgICAgIGZhZGVGcm9tSW5kZXgsXG4gICAgICAgIG92ZXJsYXlSZWYsXG4gICAgICAgIG9uU25hcFBvaW50Q2hhbmdlLFxuICAgICAgICBkaXJlY3Rpb25cbiAgICB9KTtcbiAgICB1c2VQcmV2ZW50U2Nyb2xsKHtcbiAgICAgICAgaXNEaXNhYmxlZDogIWlzT3BlbiB8fCBpc0RyYWdnaW5nIHx8ICFtb2RhbCB8fCBqdXN0UmVsZWFzZWQgfHwgIWhhc0JlZW5PcGVuZWQgfHwgZGlzYWJsZVByZXZlbnRTY3JvbGxcbiAgICB9KTtcbiAgICBjb25zdCB7IHJlc3RvcmVQb3NpdGlvblNldHRpbmcgfSA9IHVzZVBvc2l0aW9uRml4ZWQoe1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIG1vZGFsLFxuICAgICAgICBuZXN0ZWQsXG4gICAgICAgIGhhc0JlZW5PcGVuZWQsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXN0b3JhdGlvbixcbiAgICAgICAgbm9Cb2R5U3R5bGVzXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ2V0U2NhbGUoKSB7XG4gICAgICAgIHJldHVybiAod2luZG93LmlubmVyV2lkdGggLSBXSU5ET1dfVE9QX09GRlNFVCkgLyB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25QcmVzcyhldmVudCkge1xuICAgICAgICB2YXIgX2RyYXdlclJlZl9jdXJyZW50O1xuICAgICAgICBpZiAoIWRpc21pc3NpYmxlICYmICFzbmFwUG9pbnRzKSByZXR1cm47XG4gICAgICAgIGlmIChkcmF3ZXJSZWYuY3VycmVudCAmJiAhZHJhd2VyUmVmLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICBkcmF3ZXJIZWlnaHRSZWYuY3VycmVudCA9ICgoX2RyYXdlclJlZl9jdXJyZW50ID0gZHJhd2VyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZHJhd2VyUmVmX2N1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KSB8fCAwO1xuICAgICAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xuICAgICAgICBkcmFnU3RhcnRUaW1lLmN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAvLyBpT1MgZG9lc24ndCB0cmlnZ2VyIG1vdXNlVXAgYWZ0ZXIgc2Nyb2xsaW5nIHNvIHdlIG5lZWQgdG8gbGlzdGVuIHRvIHRvdWNoZWQgaW4gb3JkZXIgdG8gZGlzYWxsb3cgZHJhZ2dpbmdcbiAgICAgICAgaWYgKGlzSU9TKCkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpPT5pc0FsbG93ZWRUb0RyYWcuY3VycmVudCA9IGZhbHNlLCB7XG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHdlIG1haW50YWluIGNvcnJlY3QgcG9pbnRlciBjYXB0dXJlIGV2ZW4gd2hlbiBnb2luZyBvdXRzaWRlIG9mIHRoZSBkcmF3ZXJcbiAgICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIHBvaW50ZXJTdGFydC5jdXJyZW50ID0gaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gZXZlbnQuY2xpZW50WSA6IGV2ZW50LmNsaWVudFg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZERyYWcoZWwsIGlzRHJhZ2dpbmdJbkRpcmVjdGlvbikge1xuICAgICAgICB2YXIgX3dpbmRvd19nZXRTZWxlY3Rpb247XG4gICAgICAgIGxldCBlbGVtZW50ID0gZWw7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodGVkVGV4dCA9IChfd2luZG93X2dldFNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3dfZ2V0U2VsZWN0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHN3aXBlQW1vdW50ID0gZHJhd2VyUmVmLmN1cnJlbnQgPyBnZXRUcmFuc2xhdGUoZHJhd2VyUmVmLmN1cnJlbnQsIGRpcmVjdGlvbikgOiBudWxsO1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXZhdWwtbm8tZHJhZycpIHx8IGVsZW1lbnQuY2xvc2VzdCgnW2RhdGEtdmF1bC1uby1kcmFnXScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyB8fCBkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb3cgc2Nyb2xsaW5nIHdoZW4gYW5pbWF0aW5nXG4gICAgICAgIGlmIChvcGVuVGltZS5jdXJyZW50ICYmIGRhdGUuZ2V0VGltZSgpIC0gb3BlblRpbWUuY3VycmVudC5nZXRUaW1lKCkgPCA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3dpcGVBbW91bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nID8gc3dpcGVBbW91bnQgPiAwIDogc3dpcGVBbW91bnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgZHJhZyBpZiB0aGVyZSdzIGhpZ2hsaWdodGVkIHRleHRcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVkVGV4dCAmJiBoaWdobGlnaHRlZFRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc2FsbG93IGRyYWdnaW5nIGlmIGRyYXdlciB3YXMgc2Nyb2xsZWQgd2l0aGluIGBzY3JvbGxMb2NrVGltZW91dGBcbiAgICAgICAgaWYgKGxhc3RUaW1lRHJhZ1ByZXZlbnRlZC5jdXJyZW50ICYmIGRhdGUuZ2V0VGltZSgpIC0gbGFzdFRpbWVEcmFnUHJldmVudGVkLmN1cnJlbnQuZ2V0VGltZSgpIDwgc2Nyb2xsTG9ja1RpbWVvdXQgJiYgc3dpcGVBbW91bnQgPT09IDApIHtcbiAgICAgICAgICAgIGxhc3RUaW1lRHJhZ1ByZXZlbnRlZC5jdXJyZW50ID0gZGF0ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEcmFnZ2luZ0luRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBsYXN0VGltZURyYWdQcmV2ZW50ZWQuY3VycmVudCA9IGRhdGU7XG4gICAgICAgICAgICAvLyBXZSBhcmUgZHJhZ2dpbmcgZG93biBzbyB3ZSBzaG91bGQgYWxsb3cgc2Nyb2xsaW5nXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBjbGltYmluZyB1cCB0aGUgRE9NIHRyZWUgYXMgbG9uZyBhcyB0aGVyZSdzIGEgcGFyZW50XG4gICAgICAgIHdoaWxlKGVsZW1lbnQpe1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgc2Nyb2xsYWJsZVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRpbWVEcmFnUHJldmVudGVkLmN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBzY3JvbGxhYmxlIGFuZCBub3Qgc2Nyb2xsZWQgdG8gdGhlIHRvcCwgc28gZG9uJ3QgZHJhZ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnZGlhbG9nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNb3ZlIHVwIHRvIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBzY3JvbGxhYmxlIHBhcmVudHMgbm90IHNjcm9sbGVkIHRvIHRoZSB0b3AgZm91bmQsIHNvIGRyYWdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRHJhZyhldmVudCkge1xuICAgICAgICBpZiAoIWRyYXdlclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBrbm93IGhvdyBtdWNoIG9mIHRoZSBkcmF3ZXIgaGFzIGJlZW4gZHJhZ2dlZCBpbiBwZXJjZW50YWdlcyBzbyB0aGF0IHdlIGNhbiB0cmFuc2Zvcm0gYmFja2dyb3VuZCBhY2NvcmRpbmdseVxuICAgICAgICBpZiAoaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uTXVsdGlwbGllciA9IGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnID8gMSA6IC0xO1xuICAgICAgICAgICAgY29uc3QgZHJhZ2dlZERpc3RhbmNlID0gKHBvaW50ZXJTdGFydC5jdXJyZW50IC0gKGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGV2ZW50LmNsaWVudFkgOiBldmVudC5jbGllbnRYKSkgKiBkaXJlY3Rpb25NdWx0aXBsaWVyO1xuICAgICAgICAgICAgY29uc3QgaXNEcmFnZ2luZ0luRGlyZWN0aW9uID0gZHJhZ2dlZERpc3RhbmNlID4gMDtcbiAgICAgICAgICAgIC8vIFByZSBjb25kaXRpb24gZm9yIGRpc2FsbG93aW5nIGRyYWdnaW5nIGluIHRoZSBjbG9zZSBkaXJlY3Rpb24uXG4gICAgICAgICAgICBjb25zdCBub0Nsb3NlU25hcFBvaW50c1ByZUNvbmRpdGlvbiA9IHNuYXBQb2ludHMgJiYgIWRpc21pc3NpYmxlICYmICFpc0RyYWdnaW5nSW5EaXJlY3Rpb247XG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBkcmFnZ2luZyBkb3duIHRvIGNsb3NlIHdoZW4gZmlyc3Qgc25hcCBwb2ludCBpcyB0aGUgYWN0aXZlIG9uZSBhbmQgZGlzbWlzc2libGUgcHJvcCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAgICBpZiAobm9DbG9zZVNuYXBQb2ludHNQcmVDb25kaXRpb24gJiYgYWN0aXZlU25hcFBvaW50SW5kZXggPT09IDApIHJldHVybjtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2FwdHVyZSBsYXN0IHRpbWUgd2hlbiBkcmFnIHdpdGggc2Nyb2xsIHdhcyB0cmlnZ2VyZWQgYW5kIGhhdmUgYSB0aW1lb3V0IGJldHdlZW5cbiAgICAgICAgICAgIGNvbnN0IGFic0RyYWdnZWREaXN0YW5jZSA9IE1hdGguYWJzKGRyYWdnZWREaXN0YW5jZSk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW3ZhdWwtZHJhd2VyLXdyYXBwZXJdJyk7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBlcmNlbnRhZ2UgZHJhZ2dlZCwgd2hlcmUgMSBpcyB0aGUgY2xvc2VkIHBvc2l0aW9uXG4gICAgICAgICAgICBsZXQgcGVyY2VudGFnZURyYWdnZWQgPSBhYnNEcmFnZ2VkRGlzdGFuY2UgLyBkcmF3ZXJIZWlnaHRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IHNuYXBQb2ludFBlcmNlbnRhZ2VEcmFnZ2VkID0gZ2V0U25hcFBvaW50c1BlcmNlbnRhZ2VEcmFnZ2VkKGFic0RyYWdnZWREaXN0YW5jZSwgaXNEcmFnZ2luZ0luRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzbmFwUG9pbnRQZXJjZW50YWdlRHJhZ2dlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2VEcmFnZ2VkID0gc25hcFBvaW50UGVyY2VudGFnZURyYWdnZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBjbG9zZSBkcmFnZ2luZyBiZXlvbmQgdGhlIHNtYWxsZXN0IHNuYXAgcG9pbnQuXG4gICAgICAgICAgICBpZiAobm9DbG9zZVNuYXBQb2ludHNQcmVDb25kaXRpb24gJiYgcGVyY2VudGFnZURyYWdnZWQgPj0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNBbGxvd2VkVG9EcmFnLmN1cnJlbnQgJiYgIXNob3VsZERyYWcoZXZlbnQudGFyZ2V0LCBpc0RyYWdnaW5nSW5EaXJlY3Rpb24pKSByZXR1cm47XG4gICAgICAgICAgICBkcmF3ZXJSZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKERSQUdfQ0xBU1MpO1xuICAgICAgICAgICAgLy8gSWYgc2hvdWxkRHJhZyBnYXZlIHRydWUgb25jZSBhZnRlciBwcmVzc2luZyBkb3duIG9uIHRoZSBkcmF3ZXIsIHdlIHNldCBpc0FsbG93ZWRUb0RyYWcgdG8gdHJ1ZSBhbmQgaXQgd2lsbCByZW1haW4gdHJ1ZSB1bnRpbCB3ZSBsZXQgZ28sIHRoZXJlJ3Mgbm8gcmVhc29uIHRvIGRpc2FibGUgZHJhZ2dpbmcgbWlkIHdheSwgZXZlciwgYW5kIHRoYXQncyB0aGUgc29sdXRpb24gdG8gaXRcbiAgICAgICAgICAgIGlzQWxsb3dlZFRvRHJhZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldChkcmF3ZXJSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzbmFwUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgb25EcmFnU25hcFBvaW50cyh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWREaXN0YW5jZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVuIHRoaXMgb25seSBpZiBzbmFwUG9pbnRzIGFyZSBub3QgZGVmaW5lZCBvciBpZiB3ZSBhcmUgYXQgdGhlIGxhc3Qgc25hcCBwb2ludCAoaGlnaGVzdCBvbmUpXG4gICAgICAgICAgICBpZiAoaXNEcmFnZ2luZ0luRGlyZWN0aW9uICYmICFzbmFwUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGFtcGVuZWREcmFnZ2VkRGlzdGFuY2UgPSBkYW1wZW5WYWx1ZShkcmFnZ2VkRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gTWF0aC5taW4oZGFtcGVuZWREcmFnZ2VkRGlzdGFuY2UgKiAtMSwgMCkgKiBkaXJlY3Rpb25NdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIHNldChkcmF3ZXJSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGB0cmFuc2xhdGUzZCgwLCAke3RyYW5zbGF0ZVZhbHVlfXB4LCAwKWAgOiBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVWYWx1ZX1weCwgMCwgMClgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BhY2l0eVZhbHVlID0gMSAtIHBlcmNlbnRhZ2VEcmFnZ2VkO1xuICAgICAgICAgICAgaWYgKHNob3VsZEZhZGUgfHwgZmFkZUZyb21JbmRleCAmJiBhY3RpdmVTbmFwUG9pbnRJbmRleCA9PT0gZmFkZUZyb21JbmRleCAtIDEpIHtcbiAgICAgICAgICAgICAgICBvbkRyYWdQcm9wID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWdQcm9wKGV2ZW50LCBwZXJjZW50YWdlRHJhZ2dlZCk7XG4gICAgICAgICAgICAgICAgc2V0KG92ZXJsYXlSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBgJHtvcGFjaXR5VmFsdWV9YCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod3JhcHBlciAmJiBvdmVybGF5UmVmLmN1cnJlbnQgJiYgc2hvdWxkU2NhbGVCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBlcmNlbnRhZ2VEcmFnZ2VkIGFzIGEgZnJhY3Rpb24gKDAgdG8gMSlcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZVZhbHVlID0gTWF0aC5taW4oZ2V0U2NhbGUoKSArIHBlcmNlbnRhZ2VEcmFnZ2VkICogKDEgLSBnZXRTY2FsZSgpKSwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzVmFsdWUgPSA4IC0gcGVyY2VudGFnZURyYWdnZWQgKiA4O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gTWF0aC5tYXgoMCwgMTQgLSBwZXJjZW50YWdlRHJhZ2dlZCAqIDE0KTtcbiAgICAgICAgICAgICAgICBzZXQod3JhcHBlciwge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGAke2JvcmRlclJhZGl1c1ZhbHVlfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyBgc2NhbGUoJHtzY2FsZVZhbHVlfSkgdHJhbnNsYXRlM2QoMCwgJHt0cmFuc2xhdGVWYWx1ZX1weCwgMClgIDogYHNjYWxlKCR7c2NhbGVWYWx1ZX0pIHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlVmFsdWV9cHgsIDAsIDApYCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNuYXBQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVWYWx1ZSA9IGFic0RyYWdnZWREaXN0YW5jZSAqIGRpcmVjdGlvbk11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgc2V0KGRyYXdlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHRyYW5zbGF0ZTNkKDAsICR7dHJhbnNsYXRlVmFsdWV9cHgsIDApYCA6IGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVZhbHVlfXB4LCAwLCAwKWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBzY2FsZUJhY2tncm91bmQoZmFsc2UpO1xuICAgICAgICAgICAgcmVzdG9yZVBvc2l0aW9uU2V0dGluZygpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgdmFyIF93aW5kb3dfdmlzdWFsVmlld3BvcnQ7XG4gICAgICAgIGZ1bmN0aW9uIG9uVmlzdWFsVmlld3BvcnRDaGFuZ2UoKSB7XG4gICAgICAgICAgICBpZiAoIWRyYXdlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoaXNJbnB1dChmb2N1c2VkRWxlbWVudCkgfHwga2V5Ym9hcmRJc09wZW4uY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfd2luZG93X3Zpc3VhbFZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0SGVpZ2h0ID0gKChfd2luZG93X3Zpc3VhbFZpZXdwb3J0ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvd192aXN1YWxWaWV3cG9ydC5oZWlnaHQpIHx8IDA7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgaGVpZ2h0IG9mIHRoZSBrZXlib2FyZFxuICAgICAgICAgICAgICAgIGxldCBkaWZmRnJvbUluaXRpYWwgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB2aXN1YWxWaWV3cG9ydEhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBkcmF3ZXJIZWlnaHQgPSBkcmF3ZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxEcmF3ZXJIZWlnaHQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsRHJhd2VySGVpZ2h0LmN1cnJlbnQgPSBkcmF3ZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldEZyb21Ub3AgPSBkcmF3ZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICAgICAgLy8gdmlzdWFsVmlld3BvcnQgaGVpZ2h0IG1heSBjaGFuZ2UgZHVlIHRvIHNvbWUgc3VidGxlIGNoYW5nZXMgdG8gdGhlIGtleWJvYXJkLiBDaGVja2luZyBpZiB0aGUgaGVpZ2h0IGNoYW5nZWQgYnkgNjAgb3IgbW9yZSB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZXkga2V5Ym9hcmQgcmVhbGx5IGNoYW5nZWQgaXRzIG9wZW4gc3RhdGUuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHByZXZpb3VzRGlmZkZyb21Jbml0aWFsLmN1cnJlbnQgLSBkaWZmRnJvbUluaXRpYWwpID4gNjApIHtcbiAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmRJc09wZW4uY3VycmVudCA9ICFrZXlib2FyZElzT3Blbi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc25hcFBvaW50cyAmJiBzbmFwUG9pbnRzLmxlbmd0aCA+IDAgJiYgc25hcFBvaW50c09mZnNldCAmJiBhY3RpdmVTbmFwUG9pbnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVTbmFwUG9pbnRIZWlnaHQgPSBzbmFwUG9pbnRzT2Zmc2V0W2FjdGl2ZVNuYXBQb2ludEluZGV4XSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBkaWZmRnJvbUluaXRpYWwgKz0gYWN0aXZlU25hcFBvaW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91c0RpZmZGcm9tSW5pdGlhbC5jdXJyZW50ID0gZGlmZkZyb21Jbml0aWFsO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIHRoZSBoZWlnaHQgaWYgdGhlIGlucHV0IGlzIGluIHZpZXcsIHdoZW4gd2UgYXJlIGhlcmUgd2UgYXJlIGluIHRoZSBvcGVuZWQga2V5Ym9hcmQgc3RhdGUgc28gd2UgY2FuIGNvcnJlY3RseSBjaGVjayBpZiB0aGUgaW5wdXQgaXMgaW4gdmlld1xuICAgICAgICAgICAgICAgIGlmIChkcmF3ZXJIZWlnaHQgPiB2aXN1YWxWaWV3cG9ydEhlaWdodCB8fCBrZXlib2FyZElzT3Blbi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGRyYXdlclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0RyYXdlckhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodCA+IHZpc3VhbFZpZXdwb3J0SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEcmF3ZXJIZWlnaHQgPSB2aXN1YWxWaWV3cG9ydEhlaWdodCAtIFdJTkRPV19UT1BfT0ZGU0VUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZml4ZWQsIGRvbid0IG1vdmUgdGhlIGRyYXdlciB1cHdhcmRzIGlmIHRoZXJlJ3Mgc3BhY2UsIGJ1dCByYXRoZXIgb25seSBjaGFuZ2UgaXQncyBoZWlnaHQgc28gaXQncyBmdWxseSBzY3JvbGxhYmxlIHdoZW4gdGhlIGtleWJvYXJkIGlzIG9wZW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3ZXJSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHQgLSBNYXRoLm1heChkaWZmRnJvbUluaXRpYWwsIDApfXB4YDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdlclJlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IGAke01hdGgubWF4KG5ld0RyYXdlckhlaWdodCwgdmlzdWFsVmlld3BvcnRIZWlnaHQgLSBvZmZzZXRGcm9tVG9wKX1weGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkcmF3ZXJSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtpbml0aWFsRHJhd2VySGVpZ2h0LmN1cnJlbnR9cHhgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc25hcFBvaW50cyAmJiBzbmFwUG9pbnRzLmxlbmd0aCA+IDAgJiYgIWtleWJvYXJkSXNPcGVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuc3R5bGUuYm90dG9tID0gYDBweGA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVnYXRpdmUgYm90dG9tIHZhbHVlIHdvdWxkIG5ldmVyIG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuc3R5bGUuYm90dG9tID0gYCR7TWF0aC5tYXgoZGlmZkZyb21Jbml0aWFsLCAwKX1weGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChfd2luZG93X3Zpc3VhbFZpZXdwb3J0ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvd192aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblZpc3VhbFZpZXdwb3J0Q2hhbmdlKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB2YXIgX3dpbmRvd192aXN1YWxWaWV3cG9ydDtcbiAgICAgICAgICAgIHJldHVybiAoX3dpbmRvd192aXN1YWxWaWV3cG9ydCA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3dfdmlzdWFsVmlld3BvcnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25WaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBhY3RpdmVTbmFwUG9pbnRJbmRleCxcbiAgICAgICAgc25hcFBvaW50cyxcbiAgICAgICAgc25hcFBvaW50c09mZnNldFxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIGNsb3NlRHJhd2VyKCkge1xuICAgICAgICBpZiAoIWRyYXdlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIGNhbmNlbERyYWcoKTtcbiAgICAgICAgb25DbG9zZSA9PSBudWxsID8gdm9pZCAwIDogb25DbG9zZSgpO1xuICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHRyYW5zbGF0ZTNkKDAsICR7ZGlyZWN0aW9uID09PSAnYm90dG9tJyA/ICcxMDAlJyA6ICctMTAwJSd9LCAwKWAgOiBgdHJhbnNsYXRlM2QoJHtkaXJlY3Rpb24gPT09ICdyaWdodCcgPyAnMTAwJScgOiAnLTEwMCUnfSwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYHRyYW5zZm9ybSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWBcbiAgICAgICAgfSk7XG4gICAgICAgIHNldChvdmVybGF5UmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIG9wYWNpdHk6ICcwJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7VFJBTlNJVElPTlMuRFVSQVRJT059cyBjdWJpYy1iZXppZXIoJHtUUkFOU0lUSU9OUy5FQVNFLmpvaW4oJywnKX0pYFxuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVCYWNrZ3JvdW5kKGZhbHNlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICBzZXRJc09wZW4oZmFsc2UpO1xuICAgICAgICB9LCAzMDApO1xuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAvLyByZXNldChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdzY3JvbGxCZWhhdmlvcicpO1xuICAgICAgICAgICAgaWYgKHNuYXBQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVTbmFwUG9pbnQoc25hcFBvaW50c1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFRSQU5TSVRJT05TLkRVUkFUSU9OICogMTAwMCk7IC8vIHNlY29uZHMgdG8gbXNcbiAgICB9XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmICghaXNPcGVuICYmIHNob3VsZFNjYWxlQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgdXNlIGBvbkFuaW1hdGlvbkVuZGAgYXMgdGhlIGNvbXBvbmVudCB3aWxsIGJlIGludmlzaWJsZSBieSB0aGVuXG4gICAgICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICByZXNldChkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICByZXR1cm4gKCk9PmNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzT3BlbixcbiAgICAgICAgc2hvdWxkU2NhbGVCYWNrZ3JvdW5kXG4gICAgXSk7XG4gICAgLy8gTGF5b3V0RWZmZWN0IHRvIHByZXZlbnQgZXh0cmEgcmVuZGVyIHdoZXJlIG9wZW5Qcm9wIGFuZCBpc09wZW4gYXJlIG5vdCBzeW5jZWQgeWV0XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChvcGVuUHJvcCkge1xuICAgICAgICAgICAgc2V0SXNPcGVuKHRydWUpO1xuICAgICAgICAgICAgc2V0SGFzQmVlbk9wZW5lZCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlRHJhd2VyKCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9wZW5Qcm9wXG4gICAgXSk7XG4gICAgLy8gVGhpcyBjYW4gYmUgZG9uZSBtdWNoIGJldHRlclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBvbk9wZW5DaGFuZ2UoaXNPcGVuKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgaXNPcGVuXG4gICAgXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gICAgfSwgW10pO1xuICAgIGZ1bmN0aW9uIHJlc2V0RHJhd2VyKCkge1xuICAgICAgICBpZiAoIWRyYXdlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbdmF1bC1kcmF3ZXItd3JhcHBlcl0nKTtcbiAgICAgICAgY29uc3QgY3VycmVudFN3aXBlQW1vdW50ID0gZ2V0VHJhbnNsYXRlKGRyYXdlclJlZi5jdXJyZW50LCBkaXJlY3Rpb24pO1xuICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGB0cmFuc2Zvcm0gJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgXG4gICAgICAgIH0pO1xuICAgICAgICBzZXQob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXMgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAnMSdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERvbid0IHJlc2V0IGJhY2tncm91bmQgaWYgc3dpcGVkIHVwd2FyZHNcbiAgICAgICAgaWYgKHNob3VsZFNjYWxlQmFja2dyb3VuZCAmJiBjdXJyZW50U3dpcGVBbW91bnQgJiYgY3VycmVudFN3aXBlQW1vdW50ID4gMCAmJiBpc09wZW4pIHtcbiAgICAgICAgICAgIHNldCh3cmFwcGVyLCB7XG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBgJHtCT1JERVJfUkFESVVTfXB4YCxcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgLi4uaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8ge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke2dldFNjYWxlKCl9KSB0cmFuc2xhdGUzZCgwLCBjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtdG9wKSArIDE0cHgpLCAwKWAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ3RvcCdcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke2dldFNjYWxlKCl9KSB0cmFuc2xhdGUzZChjYWxjKGVudihzYWZlLWFyZWEtaW5zZXQtdG9wKSArIDE0cHgpLCAwLCAwKWAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ2xlZnQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6ICd0cmFuc2Zvcm0sIGJvcmRlci1yYWRpdXMnLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7VFJBTlNJVElPTlMuRFVSQVRJT059c2AsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWBcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbERyYWcoKSB7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZyB8fCAhZHJhd2VyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgZHJhd2VyUmVmLmN1cnJlbnQuY2xhc3NMaXN0LnJlbW92ZShEUkFHX0NMQVNTKTtcbiAgICAgICAgaXNBbGxvd2VkVG9EcmFnLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgc2V0SXNEcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgIGRyYWdFbmRUaW1lLmN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblJlbGVhc2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFpc0RyYWdnaW5nIHx8ICFkcmF3ZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICBkcmF3ZXJSZWYuY3VycmVudC5jbGFzc0xpc3QucmVtb3ZlKERSQUdfQ0xBU1MpO1xuICAgICAgICBpc0FsbG93ZWRUb0RyYWcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKTtcbiAgICAgICAgZHJhZ0VuZFRpbWUuY3VycmVudCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHN3aXBlQW1vdW50ID0gZ2V0VHJhbnNsYXRlKGRyYXdlclJlZi5jdXJyZW50LCBkaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXNob3VsZERyYWcoZXZlbnQudGFyZ2V0LCBmYWxzZSkgfHwgIXN3aXBlQW1vdW50IHx8IE51bWJlci5pc05hTihzd2lwZUFtb3VudCkpIHJldHVybjtcbiAgICAgICAgaWYgKGRyYWdTdGFydFRpbWUuY3VycmVudCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBjb25zdCB0aW1lVGFrZW4gPSBkcmFnRW5kVGltZS5jdXJyZW50LmdldFRpbWUoKSAtIGRyYWdTdGFydFRpbWUuY3VycmVudC5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGRpc3RNb3ZlZCA9IHBvaW50ZXJTdGFydC5jdXJyZW50IC0gKGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGV2ZW50LmNsaWVudFkgOiBldmVudC5jbGllbnRYKTtcbiAgICAgICAgY29uc3QgdmVsb2NpdHkgPSBNYXRoLmFicyhkaXN0TW92ZWQpIC8gdGltZVRha2VuO1xuICAgICAgICBpZiAodmVsb2NpdHkgPiAwLjA1KSB7XG4gICAgICAgICAgICAvLyBganVzdFJlbGVhc2VkYCBpcyBuZWVkZWQgdG8gcHJldmVudCB0aGUgZHJhd2VyIGZyb20gZm9jdXNpbmcgb24gYW4gaW5wdXQgd2hlbiB0aGUgZHJhZyBlbmRzLCBhcyBpdCdzIG5vdCB0aGUgaW50ZW50IG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAgICAgICAgICBzZXRKdXN0UmVsZWFzZWQodHJ1ZSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgc2V0SnVzdFJlbGVhc2VkKGZhbHNlKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNuYXBQb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbk11bHRpcGxpZXIgPSBkaXJlY3Rpb24gPT09ICdib3R0b20nIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IDEgOiAtMTtcbiAgICAgICAgICAgIG9uUmVsZWFzZVNuYXBQb2ludHMoe1xuICAgICAgICAgICAgICAgIGRyYWdnZWREaXN0YW5jZTogZGlzdE1vdmVkICogZGlyZWN0aW9uTXVsdGlwbGllcixcbiAgICAgICAgICAgICAgICBjbG9zZURyYXdlcixcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICBkaXNtaXNzaWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvblJlbGVhc2VQcm9wID09IG51bGwgPyB2b2lkIDAgOiBvblJlbGVhc2VQcm9wKGV2ZW50LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3ZlZCB1cHdhcmRzLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBkaXN0TW92ZWQgPiAwIDogZGlzdE1vdmVkIDwgMCkge1xuICAgICAgICAgICAgcmVzZXREcmF3ZXIoKTtcbiAgICAgICAgICAgIG9uUmVsZWFzZVByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVsZWFzZVByb3AoZXZlbnQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZWxvY2l0eSA+IFZFTE9DSVRZX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgY2xvc2VEcmF3ZXIoKTtcbiAgICAgICAgICAgIG9uUmVsZWFzZVByb3AgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVsZWFzZVByb3AoZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF9oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHZpc2libGVEcmF3ZXJIZWlnaHQgPSBNYXRoLm1pbigoX2RyYXdlclJlZl9jdXJyZW50X2dldEJvdW5kaW5nQ2xpZW50UmVjdF9oZWlnaHQgPSBkcmF3ZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpICE9IG51bGwgPyBfZHJhd2VyUmVmX2N1cnJlbnRfZ2V0Qm91bmRpbmdDbGllbnRSZWN0X2hlaWdodCA6IDAsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIGlmIChzd2lwZUFtb3VudCA+PSB2aXNpYmxlRHJhd2VySGVpZ2h0ICogY2xvc2VUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIGNsb3NlRHJhd2VyKCk7XG4gICAgICAgICAgICBvblJlbGVhc2VQcm9wID09IG51bGwgPyB2b2lkIDAgOiBvblJlbGVhc2VQcm9wKGV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25SZWxlYXNlUHJvcCA9PSBudWxsID8gdm9pZCAwIDogb25SZWxlYXNlUHJvcChldmVudCwgdHJ1ZSk7XG4gICAgICAgIHJlc2V0RHJhd2VyKCk7XG4gICAgfVxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBUcmlnZ2VyIGVudGVyIGFuaW1hdGlvbiB3aXRob3V0IHVzaW5nIENTUyBhbmltYXRpb25cbiAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgc2V0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgICAgICAgICAgIHNjcm9sbEJlaGF2aW9yOiAnYXV0bydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3BlblRpbWUuY3VycmVudCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBzY2FsZUJhY2tncm91bmQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzT3BlblxuICAgIF0pO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoZHJhd2VyUmVmLmN1cnJlbnQgJiYgdmlzaWJsZSkge1xuICAgICAgICAgICAgdmFyIF9kcmF3ZXJSZWZfY3VycmVudDtcbiAgICAgICAgICAgIC8vIEZpbmQgYWxsIHNjcm9sbGFibGUgZWxlbWVudHMgaW5zaWRlIG91ciBkcmF3ZXIgYW5kIGFzc2lnbiBhIGNsYXNzIHRvIGl0IHNvIHRoYXQgd2UgY2FuIGRpc2FibGUgb3ZlcmZsb3cgd2hlbiBkcmFnZ2luZyB0byBwcmV2ZW50IHBvaW50ZXJtb3ZlIG5vdCBiZWluZyBjYXB0dXJlZFxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBkcmF3ZXJSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IChfZHJhd2VyUmVmX2N1cnJlbnQgPSBkcmF3ZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kcmF3ZXJSZWZfY3VycmVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG4gICAgICAgICAgICBjaGlsZHJlbiA9PSBudWxsID8gdm9pZCAwIDogY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaHRtbENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKGh0bWxDaGlsZC5zY3JvbGxIZWlnaHQgPiBodG1sQ2hpbGQuY2xpZW50SGVpZ2h0IHx8IGh0bWxDaGlsZC5zY3JvbGxXaWR0aCA+IGh0bWxDaGlsZC5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBodG1sQ2hpbGQuY2xhc3NMaXN0LmFkZCgndmF1bC1zY3JvbGxhYmxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHZpc2libGVcbiAgICBdKTtcbiAgICBmdW5jdGlvbiBzY2FsZUJhY2tncm91bmQob3Blbikge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW3ZhdWwtZHJhd2VyLXdyYXBwZXJdJyk7XG4gICAgICAgIGlmICghd3JhcHBlciB8fCAhc2hvdWxkU2NhbGVCYWNrZ3JvdW5kKSByZXR1cm47XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBpZiAoc2V0QmFja2dyb3VuZENvbG9yT25TY2FsZSkge1xuICAgICAgICAgICAgICAgIGlmICghbm9Cb2R5U3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgb3JpZ2luYWwgc3R5bGVzIGluaXRpYWxseVxuICAgICAgICAgICAgICAgICAgICBzZXQoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgfHwgZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIGJvZHkgc3R5bGVzLCB3aXRoIGNhY2hlIGlnbm9yZWQsIHNvIHRoYXQgd2UgY2FuIGdldCBjb3JyZWN0IG9yaWdpbmFsIHN0eWxlcyBpbiByZXNldFxuICAgICAgICAgICAgICAgICAgICBzZXQoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ2JsYWNrJ1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQod3JhcHBlciwge1xuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogYCR7Qk9SREVSX1JBRElVU31weGAsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgIC4uLmlzVmVydGljYWwoZGlyZWN0aW9uKSA/IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtnZXRTY2FsZSgpfSkgdHJhbnNsYXRlM2QoMCwgY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCkgKyAxNHB4KSwgMClgLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICd0b3AnXG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtnZXRTY2FsZSgpfSkgdHJhbnNsYXRlM2QoY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LXRvcCkgKyAxNHB4KSwgMCwgMClgLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICdsZWZ0J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiAndHJhbnNmb3JtLCBib3JkZXItcmFkaXVzJyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke1RSQU5TSVRJT05TLkRVUkFUSU9OfXNgLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogYGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEV4aXRcbiAgICAgICAgICAgIHJlc2V0KHdyYXBwZXIsICdvdmVyZmxvdycpO1xuICAgICAgICAgICAgcmVzZXQod3JhcHBlciwgJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgcmVzZXQod3JhcHBlciwgJ2JvcmRlclJhZGl1cycpO1xuICAgICAgICAgICAgc2V0KHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6ICd0cmFuc2Zvcm0sIGJvcmRlci1yYWRpdXMnLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7VFJBTlNJVElPTlMuRFVSQVRJT059c2AsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBgY3ViaWMtYmV6aWVyKCR7VFJBTlNJVElPTlMuRUFTRS5qb2luKCcsJyl9KWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTmVzdGVkT3BlbkNoYW5nZShvKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gbyA/ICh3aW5kb3cuaW5uZXJXaWR0aCAtIE5FU1RFRF9ESVNQTEFDRU1FTlQpIC8gd2luZG93LmlubmVyV2lkdGggOiAxO1xuICAgICAgICBjb25zdCB5ID0gbyA/IC1ORVNURURfRElTUExBQ0VNRU5UIDogMDtcbiAgICAgICAgaWYgKG5lc3RlZE9wZW5DaGFuZ2VUaW1lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG5lc3RlZE9wZW5DaGFuZ2VUaW1lci5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGB0cmFuc2Zvcm0gJHtUUkFOU0lUSU9OUy5EVVJBVElPTn1zIGN1YmljLWJlemllcigke1RSQU5TSVRJT05TLkVBU0Uuam9pbignLCcpfSlgLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZX0pIHRyYW5zbGF0ZTNkKDAsICR7eX1weCwgMClgXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW8gJiYgZHJhd2VyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG5lc3RlZE9wZW5DaGFuZ2VUaW1lci5jdXJyZW50ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gZ2V0VHJhbnNsYXRlKGRyYXdlclJlZi5jdXJyZW50LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHNldChkcmF3ZXJSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHRyYW5zbGF0ZTNkKDAsICR7dHJhbnNsYXRlVmFsdWV9cHgsIDApYCA6IGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVZhbHVlfXB4LCAwLCAwKWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25OZXN0ZWREcmFnKGV2ZW50LCBwZXJjZW50YWdlRHJhZ2dlZCkge1xuICAgICAgICBpZiAocGVyY2VudGFnZURyYWdnZWQgPCAwKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGluaXRpYWxEaW0gPSBpc1ZlcnRpY2FsKGRpcmVjdGlvbikgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY29uc3QgaW5pdGlhbFNjYWxlID0gKGluaXRpYWxEaW0gLSBORVNURURfRElTUExBQ0VNRU5UKSAvIGluaXRpYWxEaW07XG4gICAgICAgIGNvbnN0IG5ld1NjYWxlID0gaW5pdGlhbFNjYWxlICsgcGVyY2VudGFnZURyYWdnZWQgKiAoMSAtIGluaXRpYWxTY2FsZSk7XG4gICAgICAgIGNvbnN0IG5ld1RyYW5zbGF0ZSA9IC1ORVNURURfRElTUExBQ0VNRU5UICsgcGVyY2VudGFnZURyYWdnZWQgKiBORVNURURfRElTUExBQ0VNRU5UO1xuICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gYHNjYWxlKCR7bmV3U2NhbGV9KSB0cmFuc2xhdGUzZCgwLCAke25ld1RyYW5zbGF0ZX1weCwgMClgIDogYHNjYWxlKCR7bmV3U2NhbGV9KSB0cmFuc2xhdGUzZCgke25ld1RyYW5zbGF0ZX1weCwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk5lc3RlZFJlbGVhc2UoZXZlbnQsIG8pIHtcbiAgICAgICAgY29uc3QgZGltID0gaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gd2luZG93LmlubmVySGVpZ2h0IDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gbyA/IChkaW0gLSBORVNURURfRElTUExBQ0VNRU5UKSAvIGRpbSA6IDE7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG8gPyAtTkVTVEVEX0RJU1BMQUNFTUVOVCA6IDA7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICBzZXQoZHJhd2VyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgdHJhbnNmb3JtICR7VFJBTlNJVElPTlMuRFVSQVRJT059cyBjdWJpYy1iZXppZXIoJHtUUkFOU0lUSU9OUy5FQVNFLmpvaW4oJywnKX0pYCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IGBzY2FsZSgke3NjYWxlfSkgdHJhbnNsYXRlM2QoMCwgJHt0cmFuc2xhdGV9cHgsIDApYCA6IGBzY2FsZSgke3NjYWxlfSkgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGV9cHgsIDAsIDApYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChEaWFsb2dQcmltaXRpdmUuUm9vdCwge1xuICAgICAgICBtb2RhbDogbW9kYWwsXG4gICAgICAgIG9uT3BlbkNoYW5nZTogKG8pPT57XG4gICAgICAgICAgICBpZiAob3BlblByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogb25PcGVuQ2hhbmdlKG8pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbykge1xuICAgICAgICAgICAgICAgIGNsb3NlRHJhd2VyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEhhc0JlZW5PcGVuZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2V0SXNPcGVuKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcGVuOiBpc09wZW5cbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRHJhd2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgICAgIGFjdGl2ZVNuYXBQb2ludCxcbiAgICAgICAgICAgIHNuYXBQb2ludHMsXG4gICAgICAgICAgICBzZXRBY3RpdmVTbmFwUG9pbnQsXG4gICAgICAgICAgICBkcmF3ZXJSZWYsXG4gICAgICAgICAgICBvdmVybGF5UmVmLFxuICAgICAgICAgICAgc2NhbGVCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgb25PcGVuQ2hhbmdlLFxuICAgICAgICAgICAgb25QcmVzcyxcbiAgICAgICAgICAgIHNldFZpc2libGUsXG4gICAgICAgICAgICBvblJlbGVhc2UsXG4gICAgICAgICAgICBvbkRyYWcsXG4gICAgICAgICAgICBkaXNtaXNzaWJsZSxcbiAgICAgICAgICAgIGhhbmRsZU9ubHksXG4gICAgICAgICAgICBpc09wZW4sXG4gICAgICAgICAgICBpc0RyYWdnaW5nLFxuICAgICAgICAgICAgc2hvdWxkRmFkZSxcbiAgICAgICAgICAgIGNsb3NlRHJhd2VyLFxuICAgICAgICAgICAgb25OZXN0ZWREcmFnLFxuICAgICAgICAgICAgb25OZXN0ZWRPcGVuQ2hhbmdlLFxuICAgICAgICAgICAgb25OZXN0ZWRSZWxlYXNlLFxuICAgICAgICAgICAga2V5Ym9hcmRJc09wZW4sXG4gICAgICAgICAgICBvcGVuUHJvcCxcbiAgICAgICAgICAgIG1vZGFsLFxuICAgICAgICAgICAgc25hcFBvaW50c09mZnNldCxcbiAgICAgICAgICAgIGRpcmVjdGlvblxuICAgICAgICB9XG4gICAgfSwgY2hpbGRyZW4pKTtcbn1cbmNvbnN0IExPTkdfSEFORExFX1BSRVNTX1RJTUVPVVQgPSAyNTA7XG5jb25zdCBET1VCTEVfVEFQX1RJTUVPVVQgPSAxMjA7XG5jb25zdCBIYW5kbGUgPSAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24oeyBwcmV2ZW50Q3ljbGUgPSBmYWxzZSwgY2hpbGRyZW4sIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBjbG9zZURyYXdlciwgaXNEcmFnZ2luZywgc25hcFBvaW50cywgYWN0aXZlU25hcFBvaW50LCBzZXRBY3RpdmVTbmFwUG9pbnQsIGRpc21pc3NpYmxlLCBoYW5kbGVPbmx5LCBvblByZXNzLCBvbkRyYWcgfSA9IHVzZURyYXdlckNvbnRleHQoKTtcbiAgICBjb25zdCBjbG9zZVRpbWVvdXRJZFJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBzaG91bGRDYW5jZWxJbnRlcmFjdGlvblJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihmYWxzZSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlU3RhcnRDeWNsZSgpIHtcbiAgICAgICAgLy8gU3RvcCBpZiB0aGlzIGlzIHRoZSBzZWNvbmQgY2xpY2sgb2YgYSBkb3VibGUgY2xpY2tcbiAgICAgICAgaWYgKHNob3VsZENhbmNlbEludGVyYWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbEludGVyYWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIGhhbmRsZUN5Y2xlU25hcFBvaW50cygpO1xuICAgICAgICB9LCBET1VCTEVfVEFQX1RJTUVPVVQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVDeWNsZVNuYXBQb2ludHMoKSB7XG4gICAgICAgIC8vIFByZXZlbnQgYWNjaWRlbnRhbCB0YXBzIHdoaWxlIHJlc2l6aW5nIGRyYXdlclxuICAgICAgICBpZiAoaXNEcmFnZ2luZyB8fCBwcmV2ZW50Q3ljbGUgfHwgc2hvdWxkQ2FuY2VsSW50ZXJhY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsSW50ZXJhY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gY2xlYXIgdGhlIHRpbWVvdXQgaWQgaWYgdGhlIHVzZXIgcmVsZWFzZXMgdGhlIGhhbmRsZSBiZWZvcmUgdGhlIGNhbmNlbCB0aW1lb3V0XG4gICAgICAgIGhhbmRsZUNhbmNlbEludGVyYWN0aW9uKCk7XG4gICAgICAgIGlmICgoIXNuYXBQb2ludHMgfHwgc25hcFBvaW50cy5sZW5ndGggPT09IDApICYmIGRpc21pc3NpYmxlKSB7XG4gICAgICAgICAgICBjbG9zZURyYXdlcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTGFzdFNuYXBQb2ludCA9IGFjdGl2ZVNuYXBQb2ludCA9PT0gc25hcFBvaW50c1tzbmFwUG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNMYXN0U25hcFBvaW50ICYmIGRpc21pc3NpYmxlKSB7XG4gICAgICAgICAgICBjbG9zZURyYXdlcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbmFwSW5kZXggPSBzbmFwUG9pbnRzLmZpbmRJbmRleCgocG9pbnQpPT5wb2ludCA9PT0gYWN0aXZlU25hcFBvaW50KTtcbiAgICAgICAgaWYgKGN1cnJlbnRTbmFwSW5kZXggPT09IC0xKSByZXR1cm47IC8vIGFjdGl2ZVNuYXBQb2ludCBub3QgZm91bmQgaW4gc25hcFBvaW50c1xuICAgICAgICBjb25zdCBuZXh0U25hcFBvaW50ID0gc25hcFBvaW50c1tjdXJyZW50U25hcEluZGV4ICsgMV07XG4gICAgICAgIHNldEFjdGl2ZVNuYXBQb2ludChuZXh0U25hcFBvaW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlU3RhcnRJbnRlcmFjdGlvbigpIHtcbiAgICAgICAgY2xvc2VUaW1lb3V0SWRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAvLyBDYW5jZWwgY2xpY2sgaW50ZXJhY3Rpb24gb24gYSBsb25nIHByZXNzXG4gICAgICAgICAgICBzaG91bGRDYW5jZWxJbnRlcmFjdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSwgTE9OR19IQU5ETEVfUFJFU1NfVElNRU9VVCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUNhbmNlbEludGVyYWN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgICBzaG91bGRDYW5jZWxJbnRlcmFjdGlvblJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBvbkNsaWNrOiBoYW5kbGVTdGFydEN5Y2xlLFxuICAgICAgICBvbkRvdWJsZUNsaWNrOiAoKT0+e1xuICAgICAgICAgICAgc2hvdWxkQ2FuY2VsSW50ZXJhY3Rpb25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBjbG9zZURyYXdlcigpO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJDYW5jZWw6IGhhbmRsZUNhbmNlbEludGVyYWN0aW9uLFxuICAgICAgICBvblBvaW50ZXJEb3duOiAoZSk9PntcbiAgICAgICAgICAgIGlmIChoYW5kbGVPbmx5KSBvblByZXNzKGUpO1xuICAgICAgICAgICAgaGFuZGxlU3RhcnRJbnRlcmFjdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJNb3ZlOiAoZSk9PntcbiAgICAgICAgICAgIGlmIChoYW5kbGVPbmx5KSBvbkRyYWcoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG9uUG9pbnRlclVwIGlzIGFscmVhZHkgaGFuZGxlZCBieSB0aGUgY29udGVudCBjb21wb25lbnRcbiAgICAgICAgcmVmOiByZWYsXG4gICAgICAgIFwidmF1bC1kcmF3ZXItdmlzaWJsZVwiOiB2aXNpYmxlID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgXCJ2YXVsLWhhbmRsZVwiOiBcIlwiLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgICAgICAuLi5yZXN0XG4gICAgfSwgLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIFwidmF1bC1oYW5kbGUtaGl0YXJlYVwiOiBcIlwiLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG4gICAgfSwgY2hpbGRyZW4pKTtcbn0pO1xuSGFuZGxlLmRpc3BsYXlOYW1lID0gJ0RyYXdlci5IYW5kbGUnO1xuY29uc3QgT3ZlcmxheSA9IC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihmdW5jdGlvbih7IGNoaWxkcmVuLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IHsgb3ZlcmxheVJlZiwgc25hcFBvaW50cywgb25SZWxlYXNlLCBzaG91bGRGYWRlLCBpc09wZW4sIHZpc2libGUgfSA9IHVzZURyYXdlckNvbnRleHQoKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZiA9IHVzZUNvbXBvc2VkUmVmcyhyZWYsIG92ZXJsYXlSZWYpO1xuICAgIGNvbnN0IGhhc1NuYXBQb2ludHMgPSBzbmFwUG9pbnRzICYmIHNuYXBQb2ludHMubGVuZ3RoID4gMDtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERpYWxvZ1ByaW1pdGl2ZS5PdmVybGF5LCB7XG4gICAgICAgIG9uTW91c2VVcDogb25SZWxlYXNlLFxuICAgICAgICByZWY6IGNvbXBvc2VkUmVmLFxuICAgICAgICBcInZhdWwtZHJhd2VyLXZpc2libGVcIjogdmlzaWJsZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgIFwidmF1bC1vdmVybGF5XCI6IFwiXCIsXG4gICAgICAgIFwidmF1bC1zbmFwLXBvaW50c1wiOiBpc09wZW4gJiYgaGFzU25hcFBvaW50cyA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgIFwidmF1bC1zbmFwLXBvaW50cy1vdmVybGF5XCI6IGlzT3BlbiAmJiBzaG91bGRGYWRlID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgLi4ucmVzdFxuICAgIH0pO1xufSk7XG5PdmVybGF5LmRpc3BsYXlOYW1lID0gJ0RyYXdlci5PdmVybGF5JztcbmNvbnN0IENvbnRlbnQgPSAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24oeyBvbk9wZW5BdXRvRm9jdXMsIG9uUG9pbnRlckRvd25PdXRzaWRlLCBvbkFuaW1hdGlvbkVuZCwgc3R5bGUsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgeyBkcmF3ZXJSZWYsIG9uUHJlc3MsIG9uUmVsZWFzZSwgb25EcmFnLCBkaXNtaXNzaWJsZSwga2V5Ym9hcmRJc09wZW4sIHNuYXBQb2ludHNPZmZzZXQsIHZpc2libGUsIGNsb3NlRHJhd2VyLCBtb2RhbCwgb3BlblByb3AsIG9uT3BlbkNoYW5nZSwgc2V0VmlzaWJsZSwgaGFuZGxlT25seSwgZGlyZWN0aW9uIH0gPSB1c2VEcmF3ZXJDb250ZXh0KCk7XG4gICAgY29uc3QgY29tcG9zZWRSZWYgPSB1c2VDb21wb3NlZFJlZnMocmVmLCBkcmF3ZXJSZWYpO1xuICAgIGNvbnN0IHBvaW50ZXJTdGFydFJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCB3YXNCZXlvbmRUaGVQb2ludFJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgaXNEZWx0YUluRGlyZWN0aW9uID0gKGRlbHRhLCBkaXJlY3Rpb24sIHRocmVzaG9sZCA9IDApPT57XG4gICAgICAgIGlmICh3YXNCZXlvbmRUaGVQb2ludFJlZi5jdXJyZW50KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gTWF0aC5hYnMoZGVsdGEueSk7XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IE1hdGguYWJzKGRlbHRhLngpO1xuICAgICAgICBjb25zdCBpc0RlbHRhWCA9IGRlbHRhWCA+IGRlbHRhWTtcbiAgICAgICAgY29uc3QgZEZhY3RvciA9IFtcbiAgICAgICAgICAgICdib3R0b20nLFxuICAgICAgICAgICAgJ3JpZ2h0J1xuICAgICAgICBdLmluY2x1ZGVzKGRpcmVjdGlvbikgPyAxIDogLTE7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0JyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUmV2ZXJzZURpcmVjdGlvbiA9IGRlbHRhLnggKiBkRmFjdG9yIDwgMDtcbiAgICAgICAgICAgIGlmICghaXNSZXZlcnNlRGlyZWN0aW9uICYmIGRlbHRhWCA+PSAwICYmIGRlbHRhWCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEZWx0YVg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpc1JldmVyc2VEaXJlY3Rpb24gPSBkZWx0YS55ICogZEZhY3RvciA8IDA7XG4gICAgICAgICAgICBpZiAoIWlzUmV2ZXJzZURpcmVjdGlvbiAmJiBkZWx0YVkgPj0gMCAmJiBkZWx0YVkgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc0RlbHRhWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3YXNCZXlvbmRUaGVQb2ludFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgLy8gVHJpZ2dlciBlbnRlciBhbmltYXRpb24gd2l0aG91dCB1c2luZyBDU1MgYW5pbWF0aW9uXG4gICAgICAgIHNldFZpc2libGUodHJ1ZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nUHJpbWl0aXZlLkNvbnRlbnQsIHtcbiAgICAgICAgXCJ2YXVsLWRyYXdlclwiOiBcIlwiLFxuICAgICAgICBcInZhdWwtZHJhd2VyLWRpcmVjdGlvblwiOiBkaXJlY3Rpb24sXG4gICAgICAgIFwidmF1bC1kcmF3ZXItdmlzaWJsZVwiOiB2aXNpYmxlID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgcmVmOiBjb21wb3NlZFJlZixcbiAgICAgICAgc3R5bGU6IHNuYXBQb2ludHNPZmZzZXQgJiYgc25hcFBvaW50c09mZnNldC5sZW5ndGggPiAwID8ge1xuICAgICAgICAgICAgJy0tc25hcC1wb2ludC1oZWlnaHQnOiBgJHtzbmFwUG9pbnRzT2Zmc2V0WzBdfXB4YCxcbiAgICAgICAgICAgIC4uLnN0eWxlXG4gICAgICAgIH0gOiBzdHlsZSxcbiAgICAgICAgb25PcGVuQXV0b0ZvY3VzOiAoZSk9PntcbiAgICAgICAgICAgIGlmIChvbk9wZW5BdXRvRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBvbk9wZW5BdXRvRm9jdXMoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfZHJhd2VyUmVmX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIChfZHJhd2VyUmVmX2N1cnJlbnQgPSBkcmF3ZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kcmF3ZXJSZWZfY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJEb3duOiAoZXZlbnQpPT57XG4gICAgICAgICAgICBpZiAoaGFuZGxlT25seSkgcmV0dXJuO1xuICAgICAgICAgICAgcmVzdC5vblBvaW50ZXJEb3duID09IG51bGwgPyB2b2lkIDAgOiByZXN0Lm9uUG9pbnRlckRvd24uY2FsbChyZXN0LCBldmVudCk7XG4gICAgICAgICAgICBwb2ludGVyU3RhcnRSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvblByZXNzKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bk91dHNpZGU6IChlKT0+e1xuICAgICAgICAgICAgb25Qb2ludGVyRG93bk91dHNpZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUG9pbnRlckRvd25PdXRzaWRlKGUpO1xuICAgICAgICAgICAgaWYgKCFtb2RhbCB8fCBlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleWJvYXJkSXNPcGVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBrZXlib2FyZElzT3Blbi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICAgICAgICBpZiAoIWRpc21pc3NpYmxlIHx8IG9wZW5Qcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZURyYXdlcigpO1xuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzT3V0c2lkZTogKGUpPT57XG4gICAgICAgICAgICBpZiAoIW1vZGFsKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Fc2NhcGVLZXlEb3duOiAoZSk9PntcbiAgICAgICAgICAgIGlmICghbW9kYWwpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJNb3ZlOiAoZXZlbnQpPT57XG4gICAgICAgICAgICBpZiAoaGFuZGxlT25seSkgcmV0dXJuO1xuICAgICAgICAgICAgcmVzdC5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiByZXN0Lm9uUG9pbnRlck1vdmUuY2FsbChyZXN0LCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXBvaW50ZXJTdGFydFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB5UG9zaXRpb24gPSBldmVudC5jbGllbnRZIC0gcG9pbnRlclN0YXJ0UmVmLmN1cnJlbnQueTtcbiAgICAgICAgICAgIGNvbnN0IHhQb3NpdGlvbiA9IGV2ZW50LmNsaWVudFggLSBwb2ludGVyU3RhcnRSZWYuY3VycmVudC54O1xuICAgICAgICAgICAgY29uc3Qgc3dpcGVTdGFydFRocmVzaG9sZCA9IGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnID8gMTAgOiAyO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB7XG4gICAgICAgICAgICAgICAgeDogeFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHk6IHlQb3NpdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGlzQWxsb3dlZFRvU3dpcGUgPSBpc0RlbHRhSW5EaXJlY3Rpb24oZGVsdGEsIGRpcmVjdGlvbiwgc3dpcGVTdGFydFRocmVzaG9sZCk7XG4gICAgICAgICAgICBpZiAoaXNBbGxvd2VkVG9Td2lwZSkgb25EcmFnKGV2ZW50KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKHhQb3NpdGlvbikgPiBzd2lwZVN0YXJ0VGhyZXNob2xkIHx8IE1hdGguYWJzKHlQb3NpdGlvbikgPiBzd2lwZVN0YXJ0VGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlclN0YXJ0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJVcDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgcmVzdC5vblBvaW50ZXJVcCA9PSBudWxsID8gdm9pZCAwIDogcmVzdC5vblBvaW50ZXJVcC5jYWxsKHJlc3QsIGV2ZW50KTtcbiAgICAgICAgICAgIHBvaW50ZXJTdGFydFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHdhc0JleW9uZFRoZVBvaW50UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIG9uUmVsZWFzZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuQ29udGVudC5kaXNwbGF5TmFtZSA9ICdEcmF3ZXIuQ29udGVudCc7XG5mdW5jdGlvbiBOZXN0ZWRSb290KHsgb25EcmFnLCBvbk9wZW5DaGFuZ2UsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IHsgb25OZXN0ZWREcmFnLCBvbk5lc3RlZE9wZW5DaGFuZ2UsIG9uTmVzdGVkUmVsZWFzZSB9ID0gdXNlRHJhd2VyQ29udGV4dCgpO1xuICAgIGlmICghb25OZXN0ZWREcmFnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRHJhd2VyLk5lc3RlZFJvb3QgbXVzdCBiZSBwbGFjZWQgaW4gYW5vdGhlciBkcmF3ZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgIG5lc3RlZDogdHJ1ZSxcbiAgICAgICAgb25DbG9zZTogKCk9PntcbiAgICAgICAgICAgIG9uTmVzdGVkT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRHJhZzogKGUsIHApPT57XG4gICAgICAgICAgICBvbk5lc3RlZERyYWcoZSwgcCk7XG4gICAgICAgICAgICBvbkRyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRHJhZyhlLCBwKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PcGVuQ2hhbmdlOiAobyk9PntcbiAgICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICAgICAgb25OZXN0ZWRPcGVuQ2hhbmdlKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25PcGVuQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBvbk9wZW5DaGFuZ2Uobyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVsZWFzZTogb25OZXN0ZWRSZWxlYXNlLFxuICAgICAgICAuLi5yZXN0XG4gICAgfSk7XG59XG5jb25zdCBEcmF3ZXIgPSB7XG4gICAgUm9vdCxcbiAgICBOZXN0ZWRSb290LFxuICAgIENvbnRlbnQsXG4gICAgSGFuZGxlLFxuICAgIE92ZXJsYXksXG4gICAgVHJpZ2dlcjogRGlhbG9nUHJpbWl0aXZlLlRyaWdnZXIsXG4gICAgUG9ydGFsOiBEaWFsb2dQcmltaXRpdmUuUG9ydGFsLFxuICAgIENsb3NlOiBEaWFsb2dQcmltaXRpdmUuQ2xvc2UsXG4gICAgVGl0bGU6IERpYWxvZ1ByaW1pdGl2ZS5UaXRsZSxcbiAgICBEZXNjcmlwdGlvbjogRGlhbG9nUHJpbWl0aXZlLkRlc2NyaXB0aW9uXG59O1xuXG5leHBvcnQgeyBEcmF3ZXIgfTtcbiJdLCJuYW1lcyI6WyJfX2luc2VydENTUyIsImNvZGUiLCJkb2N1bWVudCIsImhlYWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJhcHBlbmRDaGlsZCIsInN0eWxlU2hlZXQiLCJjc3NUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJEaWFsb2dQcmltaXRpdmUiLCJSZWFjdCIsIlJlYWN0X19kZWZhdWx0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwiRHJhd2VyQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkcmF3ZXJSZWYiLCJjdXJyZW50Iiwib3ZlcmxheVJlZiIsInNjYWxlQmFja2dyb3VuZCIsIm9uUHJlc3MiLCJvblJlbGVhc2UiLCJvbkRyYWciLCJvbk5lc3RlZERyYWciLCJvbk5lc3RlZE9wZW5DaGFuZ2UiLCJvbk5lc3RlZFJlbGVhc2UiLCJvcGVuUHJvcCIsInVuZGVmaW5lZCIsImRpc21pc3NpYmxlIiwiaGFuZGxlT25seSIsImlzT3BlbiIsImlzRHJhZ2dpbmciLCJrZXlib2FyZElzT3BlbiIsInNuYXBQb2ludHNPZmZzZXQiLCJzbmFwUG9pbnRzIiwibW9kYWwiLCJzaG91bGRGYWRlIiwiYWN0aXZlU25hcFBvaW50Iiwib25PcGVuQ2hhbmdlIiwic2V0QWN0aXZlU25hcFBvaW50IiwidmlzaWJsZSIsImNsb3NlRHJhd2VyIiwic2V0VmlzaWJsZSIsImRpcmVjdGlvbiIsInVzZURyYXdlckNvbnRleHQiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkVycm9yIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImNoYWluIiwiY2FsbGJhY2tzIiwiYXJncyIsImNhbGxiYWNrIiwiaXNNYWMiLCJ0ZXN0UGxhdGZvcm0iLCJpc0lQaG9uZSIsImlzSVBhZCIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiaXNJT1MiLCJyZSIsIndpbmRvdyIsInRlc3QiLCJwbGF0Zm9ybSIsInZpc3VhbFZpZXdwb3J0IiwiaXNTY3JvbGxhYmxlIiwibm9kZSIsImdldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldFNjcm9sbFBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJzY3JvbGxpbmdFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwibm9uVGV4dElucHV0VHlwZXMiLCJTZXQiLCJwcmV2ZW50U2Nyb2xsQ291bnQiLCJyZXN0b3JlIiwidXNlUHJldmVudFNjcm9sbCIsIm9wdGlvbnMiLCJpc0Rpc2FibGVkIiwicHJldmVudFNjcm9sbE1vYmlsZVNhZmFyaSIsInByZXZlbnRTY3JvbGxTdGFuZGFyZCIsInNldFN0eWxlIiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsYWJsZSIsImxhc3RZIiwib25Ub3VjaFN0YXJ0IiwiZSIsInRhcmdldCIsImJvZHkiLCJjaGFuZ2VkVG91Y2hlcyIsInBhZ2VZIiwib25Ub3VjaE1vdmUiLCJwcmV2ZW50RGVmYXVsdCIsInkiLCJzY3JvbGxUb3AiLCJib3R0b20iLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJvblRvdWNoRW5kIiwiaXNJbnB1dCIsImFjdGl2ZUVsZW1lbnQiLCJ0cmFuc2Zvcm0iLCJmb2N1cyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9uRm9jdXMiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsInNjcm9sbEludG9WaWV3IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJvbldpbmRvd1Njcm9sbCIsInNjcm9sbFRvIiwic2Nyb2xsWCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsWSIsInBhZ2VZT2Zmc2V0IiwicmVzdG9yZVN0eWxlcyIsInJlbW92ZUV2ZW50cyIsImFkZEV2ZW50IiwicGFzc2l2ZSIsImNhcHR1cmUiLCJlbGVtZW50IiwidmFsdWUiLCJjdXIiLCJldmVudCIsImhhbmRsZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicm9vdCIsInNjcm9sbGFibGVUb3AiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJ0YXJnZXRUb3AiLCJ0YXJnZXRCb3R0b20iLCJrZXlib2FyZEhlaWdodCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJoYXMiLCJIVE1MVGV4dEFyZWFFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc0NvbnRlbnRFZGl0YWJsZSIsInNldFJlZiIsInJlZiIsImNvbXBvc2VSZWZzIiwicmVmcyIsImZvckVhY2giLCJ1c2VDb21wb3NlZFJlZnMiLCJ1c2VDYWxsYmFjayIsInByZXZpb3VzQm9keVBvc2l0aW9uIiwidXNlUG9zaXRpb25GaXhlZCIsIm5lc3RlZCIsImhhc0JlZW5PcGVuZWQiLCJwcmV2ZW50U2Nyb2xsUmVzdG9yYXRpb24iLCJub0JvZHlTdHlsZXMiLCJhY3RpdmVVcmwiLCJzZXRBY3RpdmVVcmwiLCJ1c2VTdGF0ZSIsImxvY2F0aW9uIiwiaHJlZiIsInNjcm9sbFBvcyIsInVzZVJlZiIsInNldFBvc2l0aW9uRml4ZWQiLCJwb3NpdGlvbiIsImxlZnQiLCJyaWdodCIsInNldFByb3BlcnR5IiwiT2JqZWN0IiwiYXNzaWduIiwic2V0VGltZW91dCIsImJvdHRvbUJhckhlaWdodCIsInJlc3RvcmVQb3NpdGlvblNldHRpbmciLCJwYXJzZUludCIsIngiLCJvblNjcm9sbCIsImlzU3RhbmRhbG9uZSIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwiY2FjaGUiLCJXZWFrTWFwIiwic2V0IiwiZWwiLCJzdHlsZXMiLCJpZ25vcmVDYWNoZSIsIm9yaWdpbmFsU3R5bGVzIiwiZW50cmllcyIsImtleSIsInN0YXJ0c1dpdGgiLCJyZXNldCIsInByb3AiLCJnZXQiLCJpc1ZlcnRpY2FsIiwiZ2V0VHJhbnNsYXRlIiwid2Via2l0VHJhbnNmb3JtIiwibW96VHJhbnNmb3JtIiwibWF0IiwibWF0Y2giLCJwYXJzZUZsb2F0Iiwic3BsaXQiLCJkYW1wZW5WYWx1ZSIsInYiLCJNYXRoIiwibG9nIiwiVFJBTlNJVElPTlMiLCJEVVJBVElPTiIsIkVBU0UiLCJWRUxPQ0lUWV9USFJFU0hPTEQiLCJ1c2VDYWxsYmFja1JlZiIsImNhbGxiYWNrUmVmIiwidXNlTWVtbyIsImNhbGwiLCJ1c2VVbmNvbnRyb2xsZWRTdGF0ZSIsImRlZmF1bHRQcm9wIiwib25DaGFuZ2UiLCJ1bmNvbnRyb2xsZWRTdGF0ZSIsInByZXZWYWx1ZVJlZiIsImhhbmRsZUNoYW5nZSIsInVzZUNvbnRyb2xsYWJsZVN0YXRlIiwidW5jb250cm9sbGVkUHJvcCIsInNldFVuY29udHJvbGxlZFByb3AiLCJpc0NvbnRyb2xsZWQiLCJzZXRWYWx1ZSIsIm5leHRWYWx1ZSIsInNldHRlciIsInVzZVNuYXBQb2ludHMiLCJhY3RpdmVTbmFwUG9pbnRQcm9wIiwic2V0QWN0aXZlU25hcFBvaW50UHJvcCIsImZhZGVGcm9tSW5kZXgiLCJvblNuYXBQb2ludENoYW5nZSIsImlzTGFzdFNuYXBQb2ludCIsImxlbmd0aCIsIk51bWJlciIsImlzTmFOIiwiYWN0aXZlU25hcFBvaW50SW5kZXgiLCJmaW5kSW5kZXgiLCJzbmFwUG9pbnQiLCJfc25hcFBvaW50c19tYXAiLCJtYXAiLCJoYXNXaW5kb3ciLCJpc1B4Iiwic25hcFBvaW50QXNOdW1iZXIiLCJ3aWR0aCIsImFjdGl2ZVNuYXBQb2ludE9mZnNldCIsInNuYXBUb1BvaW50IiwiZGltZW5zaW9uIiwiX3NuYXBQb2ludHNPZmZzZXRfZmluZEluZGV4IiwibmV3U25hcFBvaW50SW5kZXgiLCJzbmFwUG9pbnREaW0iLCJ0cmFuc2l0aW9uIiwiam9pbiIsIm9wYWNpdHkiLCJfc25hcFBvaW50c19maW5kSW5kZXgiLCJuZXdJbmRleCIsImRyYWdnZWREaXN0YW5jZSIsInZlbG9jaXR5IiwiY3VycmVudFBvc2l0aW9uIiwiaXNPdmVybGF5U25hcFBvaW50IiwiaXNGaXJzdCIsImhhc0RyYWdnZWRVcCIsImNsb3Nlc3RTbmFwUG9pbnQiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyciIsImFicyIsImRpbSIsImRyYWdEaXJlY3Rpb24iLCJuZXdWYWx1ZSIsImdldFBlcmNlbnRhZ2VEcmFnZ2VkIiwiYWJzRHJhZ2dlZERpc3RhbmNlIiwiaXNEcmFnZ2luZ0Rvd24iLCJpc092ZXJsYXlTbmFwUG9pbnRPckhpZ2hlciIsInRhcmdldFNuYXBQb2ludEluZGV4Iiwic25hcFBvaW50RGlzdGFuY2UiLCJwZXJjZW50YWdlRHJhZ2dlZCIsIkNMT1NFX1RIUkVTSE9MRCIsIlNDUk9MTF9MT0NLX1RJTUVPVVQiLCJCT1JERVJfUkFESVVTIiwiTkVTVEVEX0RJU1BMQUNFTUVOVCIsIldJTkRPV19UT1BfT0ZGU0VUIiwiRFJBR19DTEFTUyIsIlJvb3QiLCJvcGVuIiwiY2hpbGRyZW4iLCJzaG91bGRTY2FsZUJhY2tncm91bmQiLCJvbkRyYWdQcm9wIiwib25SZWxlYXNlUHJvcCIsInNldEJhY2tncm91bmRDb2xvck9uU2NhbGUiLCJjbG9zZVRocmVzaG9sZCIsInNjcm9sbExvY2tUaW1lb3V0IiwiZml4ZWQiLCJvbkNsb3NlIiwiZGlzYWJsZVByZXZlbnRTY3JvbGwiLCJfZHJhd2VyUmVmX2N1cnJlbnQiLCJzZXRJc09wZW4iLCJzZXRIYXNCZWVuT3BlbmVkIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJzZXRJc0RyYWdnaW5nIiwianVzdFJlbGVhc2VkIiwic2V0SnVzdFJlbGVhc2VkIiwib3BlblRpbWUiLCJkcmFnU3RhcnRUaW1lIiwiZHJhZ0VuZFRpbWUiLCJsYXN0VGltZURyYWdQcmV2ZW50ZWQiLCJpc0FsbG93ZWRUb0RyYWciLCJuZXN0ZWRPcGVuQ2hhbmdlVGltZXIiLCJwb2ludGVyU3RhcnQiLCJwcmV2aW91c0RpZmZGcm9tSW5pdGlhbCIsImRyYXdlckhlaWdodFJlZiIsImluaXRpYWxEcmF3ZXJIZWlnaHQiLCJEYXRlIiwib25SZWxlYXNlU25hcFBvaW50cyIsIm9uRHJhZ1NuYXBQb2ludHMiLCJnZXRTbmFwUG9pbnRzUGVyY2VudGFnZURyYWdnZWQiLCJnZXRTY2FsZSIsImNvbnRhaW5zIiwic2V0UG9pbnRlckNhcHR1cmUiLCJwb2ludGVySWQiLCJjbGllbnRZIiwiY2xpZW50WCIsInNob3VsZERyYWciLCJpc0RyYWdnaW5nSW5EaXJlY3Rpb24iLCJfd2luZG93X2dldFNlbGVjdGlvbiIsImhpZ2hsaWdodGVkVGV4dCIsImdldFNlbGVjdGlvbiIsInRvU3RyaW5nIiwic3dpcGVBbW91bnQiLCJkYXRlIiwiaGFzQXR0cmlidXRlIiwiY2xvc2VzdCIsImdldFRpbWUiLCJnZXRBdHRyaWJ1dGUiLCJwYXJlbnROb2RlIiwiZGlyZWN0aW9uTXVsdGlwbGllciIsIm5vQ2xvc2VTbmFwUG9pbnRzUHJlQ29uZGl0aW9uIiwid3JhcHBlciIsInF1ZXJ5U2VsZWN0b3IiLCJzbmFwUG9pbnRQZXJjZW50YWdlRHJhZ2dlZCIsImNsYXNzTGlzdCIsImFkZCIsImRhbXBlbmVkRHJhZ2dlZERpc3RhbmNlIiwidHJhbnNsYXRlVmFsdWUiLCJtaW4iLCJvcGFjaXR5VmFsdWUiLCJzY2FsZVZhbHVlIiwiYm9yZGVyUmFkaXVzVmFsdWUiLCJtYXgiLCJib3JkZXJSYWRpdXMiLCJfd2luZG93X3Zpc3VhbFZpZXdwb3J0Iiwib25WaXN1YWxWaWV3cG9ydENoYW5nZSIsImZvY3VzZWRFbGVtZW50IiwidmlzdWFsVmlld3BvcnRIZWlnaHQiLCJkaWZmRnJvbUluaXRpYWwiLCJkcmF3ZXJIZWlnaHQiLCJvZmZzZXRGcm9tVG9wIiwiYWN0aXZlU25hcFBvaW50SGVpZ2h0IiwibmV3RHJhd2VySGVpZ2h0IiwiY2FuY2VsRHJhZyIsImlkIiwiY2xlYXJUaW1lb3V0IiwicmVzZXREcmF3ZXIiLCJjdXJyZW50U3dpcGVBbW91bnQiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24iLCJyZW1vdmUiLCJ0aW1lVGFrZW4iLCJkaXN0TW92ZWQiLCJfZHJhd2VyUmVmX2N1cnJlbnRfZ2V0Qm91bmRpbmdDbGllbnRSZWN0X2hlaWdodCIsInZpc2libGVEcmF3ZXJIZWlnaHQiLCJzY3JvbGxCZWhhdmlvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjaGlsZCIsImh0bWxDaGlsZCIsInNjcm9sbFdpZHRoIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRDb2xvciIsIm8iLCJzY2FsZSIsImluaXRpYWxEaW0iLCJpbml0aWFsU2NhbGUiLCJuZXdTY2FsZSIsIm5ld1RyYW5zbGF0ZSIsInRyYW5zbGF0ZSIsIlByb3ZpZGVyIiwiTE9OR19IQU5ETEVfUFJFU1NfVElNRU9VVCIsIkRPVUJMRV9UQVBfVElNRU9VVCIsIkhhbmRsZSIsImZvcndhcmRSZWYiLCJwcmV2ZW50Q3ljbGUiLCJyZXN0IiwiY2xvc2VUaW1lb3V0SWRSZWYiLCJzaG91bGRDYW5jZWxJbnRlcmFjdGlvblJlZiIsImhhbmRsZVN0YXJ0Q3ljbGUiLCJoYW5kbGVDYW5jZWxJbnRlcmFjdGlvbiIsImhhbmRsZUN5Y2xlU25hcFBvaW50cyIsImN1cnJlbnRTbmFwSW5kZXgiLCJwb2ludCIsIm5leHRTbmFwUG9pbnQiLCJoYW5kbGVTdGFydEludGVyYWN0aW9uIiwib25DbGljayIsIm9uRG91YmxlQ2xpY2siLCJvblBvaW50ZXJDYW5jZWwiLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyTW92ZSIsImRpc3BsYXlOYW1lIiwiT3ZlcmxheSIsImNvbXBvc2VkUmVmIiwiaGFzU25hcFBvaW50cyIsIm9uTW91c2VVcCIsIkNvbnRlbnQiLCJvbk9wZW5BdXRvRm9jdXMiLCJvblBvaW50ZXJEb3duT3V0c2lkZSIsIm9uQW5pbWF0aW9uRW5kIiwicG9pbnRlclN0YXJ0UmVmIiwid2FzQmV5b25kVGhlUG9pbnRSZWYiLCJpc0RlbHRhSW5EaXJlY3Rpb24iLCJkZWx0YSIsInRocmVzaG9sZCIsImRlbHRhWSIsImRlbHRhWCIsImlzRGVsdGFYIiwiZEZhY3RvciIsImluY2x1ZGVzIiwiaXNSZXZlcnNlRGlyZWN0aW9uIiwiZGVmYXVsdFByZXZlbnRlZCIsIm9uRm9jdXNPdXRzaWRlIiwib25Fc2NhcGVLZXlEb3duIiwieVBvc2l0aW9uIiwieFBvc2l0aW9uIiwic3dpcGVTdGFydFRocmVzaG9sZCIsInBvaW50ZXJUeXBlIiwiaXNBbGxvd2VkVG9Td2lwZSIsIm9uUG9pbnRlclVwIiwiTmVzdGVkUm9vdCIsInAiLCJEcmF3ZXIiLCJUcmlnZ2VyIiwiUG9ydGFsIiwiQ2xvc2UiLCJUaXRsZSIsIkRlc2NyaXB0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/vaul/dist/index.mjs\n");

/***/ })

};
;